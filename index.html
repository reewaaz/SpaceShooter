<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON TITAN: MULTIPLAYER</title>
    <!-- External Libraries for Networking and QR -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Teko:wght@400;600&display=swap');

        body {
            margin: 0; overflow: hidden; background-color: #050508;
            color: #fff; font-family: 'Teko', sans-serif;
            touch-action: none; user-select: none; cursor: none;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* UI LAYER */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        .hud-top {
            display: flex; justify-content: space-between;
            padding: 20px 30px; font-size: 35px; letter-spacing: 2px;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        }

        #health-container {
            position: absolute; bottom: 40px; left: 50%;
            transform: translateX(-50%); width: 250px; height: 10px;
            background: rgba(255, 255, 255, 0.1); border: 1px solid #555;
            border-radius: 5px; overflow: hidden;
        }
        #health-fill { width: 100%; height: 100%; background: #0f0; transition: width 0.1s; }

        /* SCREENS */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 8, 0.95); display: flex;
            flex-direction: column; justify-content: center; align-items: center;
            pointer-events: auto; z-index: 20; text-align: center;
        }

        h1 {
            font-size: 70px; margin: 0; line-height: 0.8;
            background: linear-gradient(to bottom, #0ff, #f0f);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }

        .btn {
            padding: 15px 40px; font-family: 'Teko'; font-size: 24px;
            color: #0ff; background: none; border: 2px solid #0ff;
            cursor: pointer; margin: 10px; border-radius: 5px;
        }
        .btn:hover { background: rgba(0, 255, 255, 0.1); }

        #qr-container { background: white; padding: 10px; margin-top: 20px; display: none; }
        #status-msg { color: #f0f; font-size: 20px; margin-top: 10px; }

        .hidden { display: none !important; }
        #crosshair {
            position: absolute; width: 30px; height: 30px;
            border: 2px solid #ff0; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; display: none;
        }
    </style>
</head>
<body>

    <div id="crosshair"></div>
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="score-display">0</div>
            <div id="difficulty-display">THREAT: LOW</div>
        </div>
        <div id="health-container"><div id="health-fill"></div></div>
    </div>

    <!-- MAIN MENU -->
    <div id="start-screen" class="screen">
        <h1>NEON<br>TITAN</h1>
        <p style="color: #888;">CO-OP SURVIVAL</p>
        
        <button class="btn" onclick="Game.start(false)">SOLO MISSION</button>
        <button class="btn" onclick="Net.hostGame()">HOST MISSION (QR)</button>
        
        <div id="qr-container">
            <div id="qrcode"></div>
            <p style="color: black; margin-top: 5px; font-weight: bold;">SCAN TO JOIN</p>
        </div>
        <div id="status-msg"></div>
    </div>

    <!-- GAME OVER -->
    <div id="game-over-screen" class="screen hidden">
        <h1 style="color: #f00;">MISSION FAILED</h1>
        <p id="final-score">SCORE: 0</p>
        <button class="btn" onclick="location.reload()">REBOOT</button>
    </div>

    <script>
        /** AUDIO & HAPTICS ENGINE **/
        const Feedback = {
            ctx: null,
            init() {
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            },
            play(freq, type, dur, vol, slide = false) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                if (slide) osc.frequency.exponentialRampToValueAtTime(freq / 4, this.ctx.currentTime + dur);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + dur);
            },
            shoot() { this.play(400, 'triangle', 0.1, 0.05, true); },
            hit() { 
                this.play(150, 'square', 0.1, 0.1); 
                if (navigator.vibrate) navigator.vibrate(40); // Haptic
            },
            explode() { this.play(60, 'sawtooth', 0.3, 0.15, true); }
        };

        /** NETWORK ENGINE (PeerJS) **/
        const Net = {
            peer: null,
            conn: null,
            isHost: false,
            role: null, // 'host' or 'client'
            id: null,
            
            init() {
                const urlParams = new URLSearchParams(window.location.search);
                const joinId = urlParams.get('join');
                
                this.peer = new Peer();
                this.peer.on('open', (id) => {
                    this.id = id;
                    if (joinId) this.joinGame(joinId);
                });

                this.peer.on('connection', (c) => {
                    this.conn = c;
                    this.setupEvents();
                    document.getElementById('status-msg').innerText = "PLAYER JOINED!";
                    setTimeout(() => Game.start(true), 1000);
                });
            },

            hostGame() {
                this.isHost = true;
                this.role = 'host';
                document.getElementById('qr-container').style.display = 'block';
                const joinUrl = `${window.location.origin}${window.location.pathname}?join=${this.id}`;
                new QRCode(document.getElementById("qrcode"), { text: joinUrl, width: 128, height: 128 });
                document.getElementById('status-msg').innerText = "WAITING FOR PILOT...";
            },

            joinGame(id) {
                this.role = 'client';
                this.isHost = false;
                this.conn = this.peer.connect(id);
                this.setupEvents();
                document.getElementById('status-msg').innerText = "CONNECTING TO HOST...";
            },

            setupEvents() {
                this.conn.on('open', () => {
                    if (this.role === 'client') Game.start(true);
                });
                this.conn.on('data', (data) => {
                    if (this.role === 'client') {
                        // Client receives state from host
                        Game.players = data.players;
                        Game.enemies = data.enemies;
                        Game.bullets = data.bullets;
                        Game.score = data.score;
                        Game.gameTime = data.gameTime;
                    } else {
                        // Host receives input from client
                        Game.remoteInput = data.input;
                    }
                });
            },

            send(data) {
                if (this.conn && this.conn.open) this.conn.send(data);
            }
        };

        /** GAME ENGINE **/
        const Game = {
            canvas: document.getElementById('gameCanvas'),
            ctx: null,
            active: false,
            score: 0,
            gameTime: 0,
            spawnTimer: 0,
            
            // Entities
            players: {}, // ID: {x, y, hp, angle}
            enemies: [],
            bullets: [],
            
            // Local Control
            myId: null,
            localInput: { dx: 0, dy: 0, angle: 0, shooting: false },
            remoteInput: { dx: 0, dy: 0, angle: 0, shooting: false },

            init() {
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.setupInputs();
                Net.init();
            },

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            },

            start(multiplayer) {
                Feedback.init();
                this.active = true;
                this.myId = Net.id || 'solo';
                this.players[this.myId] = { x: this.canvas.width/2, y: this.canvas.height/2, hp: 100, angle: 0, color: '#0ff' };
                
                if (multiplayer) {
                    const otherId = Net.role === 'host' ? Net.conn.peer : Net.id;
                    this.players[otherId] = { x: this.canvas.width/2, y: this.canvas.height/2, hp: 100, angle: 0, color: '#f0f' };
                }

                document.getElementById('start-screen').classList.add('hidden');
                requestAnimationFrame((ts) => this.loop(ts, ts));
            },

            loop(ts, last) {
                if (!this.active) return;
                const dt = (ts - last) / 1000;
                
                this.update(dt);
                this.draw();

                // Networking
                if (Net.role === 'host') {
                    Net.send({ players: this.players, enemies: this.enemies, bullets: this.bullets, score: this.score, gameTime: this.gameTime });
                } else if (Net.role === 'client') {
                    Net.send({ input: this.localInput });
                }

                requestAnimationFrame((newTs) => this.loop(newTs, ts));
            },

            update(dt) {
                if (Net.role === 'client') return; // Client only renders what Host says

                // Update Host & simulate Remote Player
                this.handlePlayerLogic(this.myId, this.localInput, dt);
                
                const playerIds = Object.keys(this.players);
                if (playerIds.length > 1) {
                    const otherId = playerIds.find(id => id !== this.myId);
                    this.handlePlayerLogic(otherId, this.remoteInput, dt);
                }

                // Difficulty & Spawning
                this.gameTime += dt;
                this.spawnTimer -= dt;
                if (this.spawnTimer <= 0) {
                    this.spawnEnemy();
                    this.spawnTimer = Math.max(0.4, 2.0 - (this.gameTime * 0.02));
                }

                // Bullets
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    let b = this.bullets[i];
                    b.x += b.vx * dt; b.y += b.vy * dt;
                    if (b.x < 0 || b.x > this.canvas.width || b.y < 0 || b.y > this.canvas.height) {
                        this.bullets.splice(i, 1); continue;
                    }
                    // Bullet -> Enemy Collision
                    this.enemies.forEach((e, ei) => {
                        if (Math.hypot(b.x - e.x, b.y - e.y) < 30) {
                            e.hp--;
                            this.bullets.splice(i, 1);
                            if (e.hp <= 0) {
                                this.enemies.splice(ei, 1);
                                this.score += 100;
                                Feedback.explode();
                            } else {
                                Feedback.hit();
                            }
                        }
                    });
                }

                // Enemies
                this.enemies.forEach(e => {
                    // Follow nearest player
                    let target = null, minDist = 9999;
                    for (let id in this.players) {
                        let d = Math.hypot(this.players[id].x - e.x, this.players[id].y - e.y);
                        if (d < minDist) { minDist = d; target = this.players[id]; }
                    }
                    
                    let angle = Math.atan2(target.y - e.y, target.x - e.x);
                    e.x += Math.cos(angle) * (60 + this.gameTime * 2) * dt;
                    e.y += Math.sin(angle) * (60 + this.gameTime * 2) * dt;

                    // Enemy -> Player Collision
                    if (minDist < 40) {
                        target.hp -= 20 * dt;
                        if (Math.random() > 0.95) Feedback.hit();
                        if (target.hp <= 0) this.gameOver();
                    }
                });

                document.getElementById('score-display').innerText = this.score;
                document.getElementById('health-fill').style.width = this.players[this.myId].hp + '%';
            },

            handlePlayerLogic(id, input, dt) {
                const p = this.players[id];
                if (!p) return;

                // Move
                p.x += input.dx * 300 * dt;
                p.y += input.dy * 300 * dt;
                p.angle = input.angle;

                // Constrain
                p.x = Math.max(20, Math.min(this.canvas.width - 20, p.x));
                p.y = Math.max(20, Math.min(this.canvas.height - 20, p.y));

                // Shoot
                p.cd = (p.cd || 0) - dt;
                if (input.shooting && p.cd <= 0) {
                    this.bullets.push({
                        x: p.x, y: p.y,
                        vx: Math.cos(p.angle) * 800,
                        vy: Math.sin(p.angle) * 800,
                        owner: id
                    });
                    p.cd = 0.15;
                    Feedback.shoot();
                }
            },

            spawnEnemy() {
                const side = Math.floor(Math.random() * 4);
                let x, y;
                if (side === 0) { x = Math.random() * this.canvas.width; y = -50; }
                else if (side === 1) { x = this.canvas.width + 50; y = Math.random() * this.canvas.height; }
                else if (side === 2) { x = Math.random() * this.canvas.width; y = this.canvas.height + 50; }
                else { x = -50; y = Math.random() * this.canvas.height; }
                this.enemies.push({ x, y, hp: 1 + Math.floor(this.gameTime/40) });
            },

            draw() {
                this.ctx.fillStyle = '#050508';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Grid
                this.ctx.strokeStyle = '#111';
                this.ctx.beginPath();
                for(let i=0; i<this.canvas.width; i+=50) { this.ctx.moveTo(i,0); this.ctx.lineTo(i,this.canvas.height); }
                for(let i=0; i<this.canvas.height; i+=50) { this.ctx.moveTo(0,i); this.ctx.lineTo(this.canvas.width,i); }
                this.ctx.stroke();

                // Draw Players
                for (let id in this.players) {
                    const p = this.players[id];
                    this.ctx.save();
                    this.ctx.translate(p.x, p.y);
                    this.ctx.rotate(p.angle);
                    this.ctx.shadowBlur = 15; this.ctx.shadowColor = p.color;
                    this.ctx.strokeStyle = p.color; this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(20, 0); this.ctx.lineTo(-15, 15); this.ctx.lineTo(-15, -15);
                    this.ctx.closePath(); this.ctx.stroke();
                    this.ctx.restore();
                }

                // Draw Enemies
                this.enemies.forEach(e => {
                    this.ctx.shadowBlur = 10; this.ctx.shadowColor = '#f0f';
                    this.ctx.strokeStyle = '#f0f';
                    this.ctx.strokeRect(e.x - 15, e.y - 15, 30, 30);
                });

                // Draw Bullets
                this.bullets.forEach(b => {
                    this.ctx.fillStyle = '#ff0';
                    this.ctx.shadowBlur = 5; this.ctx.shadowColor = '#ff0';
                    this.ctx.beginPath();
                    this.ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            },

            gameOver() {
                this.active = false;
                document.getElementById('final-score').innerText = "SCORE: " + this.score;
                document.getElementById('game-over-screen').classList.remove('hidden');
            },

            setupInputs() {
                // Mobile Twin-stick Logic
                let joyL = { active: false, ox: 0, oy: 0 };
                let joyR = { active: false, ox: 0, oy: 0 };

                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    for (let t of e.changedTouches) {
                        if (t.clientX < this.canvas.width / 2) {
                            joyL = { active: true, id: t.identifier, ox: t.clientX, oy: t.clientY };
                        } else {
                            joyR = { active: true, id: t.identifier, ox: t.clientX, oy: t.clientY };
                        }
                    }
                });

                this.canvas.addEventListener('touchmove', (e) => {
                    for (let t of e.changedTouches) {
                        if (joyL.active && t.identifier === joyL.id) {
                            this.localInput.dx = (t.clientX - joyL.ox) / 50;
                            this.localInput.dy = (t.clientY - joyL.oy) / 50;
                        }
                        if (joyR.active && t.identifier === joyR.id) {
                            const rx = t.clientX - joyR.ox;
                            const ry = t.clientY - joyR.oy;
                            if (Math.hypot(rx, ry) > 10) {
                                this.localInput.angle = Math.atan2(ry, rx);
                                this.localInput.shooting = true;
                            }
                        }
                    }
                });

                const end = (e) => {
                    for (let t of e.changedTouches) {
                        if (joyL.id === t.identifier) { joyL.active = false; this.localInput.dx = 0; this.localInput.dy = 0; }
                        if (joyR.id === t.identifier) { joyR.active = false; this.localInput.shooting = false; }
                    }
                };
                this.canvas.addEventListener('touchend', end);
                
                // Desktop
                window.addEventListener('keydown', e => {
                    if (e.key === 'w') this.localInput.dy = -1;
                    if (e.key === 's') this.localInput.dy = 1;
                    if (e.key === 'a') this.localInput.dx = -1;
                    if (e.key === 'd') this.localInput.dx = 1;
                });
                window.addEventListener('keyup', e => {
                    if (['w', 's'].includes(e.key)) this.localInput.dy = 0;
                    if (['a', 'd'].includes(e.key)) this.localInput.dx = 0;
                });
                window.addEventListener('mousemove', e => {
                    const p = this.players[this.myId];
                    if (p) this.localInput.angle = Math.atan2(e.clientY - p.y, e.clientX - p.x);
                });
                window.addEventListener('mousedown', () => this.localInput.shooting = true);
                window.addEventListener('mouseup', () => this.localInput.shooting = false);
            }
        };

        Game.init();
    </script>
</body>
</html>
