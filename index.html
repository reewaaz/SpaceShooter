<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Twin Stick Shooter Prototype</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; /* Prevents scrolling on mobile */
            user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let touches pass through to canvas controls */
        }

        /* Weapon Selector */
        #weapon-selector {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }

        .weapon-btn {
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #555;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .weapon-btn.active {
            border-color: #0f0;
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 10px #0f0;
        }

        /* HP Bar */
        #hp-container {
            position: absolute;
            bottom: 30px;
            right: 180px; /* Positioned to left of right stick */
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #hp-bar-bg {
            width: 150px;
            height: 20px;
            background: #333;
            border: 2px solid white;
            border-radius: 10px;
            overflow: hidden;
        }

        #hp-bar-fill {
            width: 100%;
            height: 100%;
            background: #0f0;
            transition: width 0.2s;
        }

        /* Joystick Visuals (drawn by canvas, but zones defined here) */
        .joystick-zone {
            position: absolute;
            bottom: 0;
            width: 50%;
            height: 50%;
            pointer-events: auto;
        }
        #left-zone { left: 0; }
        #right-zone { right: 0; }

        /* Joystick Hint Text */
        .zone-hint {
            position: absolute;
            bottom: 50px;
            width: 100%;
            text-align: center;
            opacity: 0.3;
            font-size: 14px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- Invisible Touch Zones -->
    <div id="left-zone" class="joystick-zone">
        <div class="zone-hint">MOVE</div>
    </div>
    <div id="right-zone" class="joystick-zone">
        <div class="zone-hint">AIM & SHOOT</div>
    </div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div id="weapon-selector">
            <div class="weapon-btn active" id="btn-rail" onclick="setWeapon('rail')">üìè</div> <!-- Rail -->
            <div class="weapon-btn" id="btn-triple" onclick="setWeapon('triple')">‚ú®</div> <!-- Triple -->
            <div class="weapon-btn" id="btn-lightning" onclick="setWeapon('lightning')">‚ö°</div> <!-- Lightning -->
            <div class="weapon-btn" id="btn-laser" onclick="setWeapon('laser')">üî¥</div> <!-- Laser -->
        </div>

        <div id="hp-container">
            <span>HP:</span>
            <div id="hp-bar-bg">
                <div id="hp-bar-fill"></div>
            </div>
        </div>
    </div>

<script>
/**
 * TWIN STICK SHOOTER ENGINE
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Game State
let lastTime = 0;
let score = 0;
let gameOver = false;

// Input State
const input = {
    leftStick: { x: 0, y: 0, active: false, originX: 0, originY: 0, currX: 0, currY: 0 },
    rightStick: { x: 0, y: 0, active: false, originX: 0, originY: 0, currX: 0, currY: 0 }
};

// Player Config
const player = {
    x: 0,
    y: 0,
    radius: 15,
    speed: 5,
    angle: 0,
    hp: 100,
    maxHp: 100,
    weapon: 'rail',
    cooldown: 0
};

// Weapon Configs
const weapons = {
    rail: { color: '#0ff', cooldown: 40, speed: 25, damage: 50, type: 'projectile', piercing: true },
    triple: { color: '#ff0', cooldown: 15, speed: 12, damage: 15, type: 'spread' },
    lightning: { color: '#b0f', cooldown: 30, range: 250, damage: 40, type: 'instant' },
    laser: { color: '#f00', cooldown: 0, range: 800, damage: 1, type: 'beam' } // Low dmg but high tick rate
};

// Entities
let bullets = [];
let enemies = [];
let particles = [];
let damageNumbers = [];

// --- RESIZE HANDLING ---
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    // Reset player to center if first run
    if (player.x === 0) {
        player.x = canvas.width / 2;
        player.y = canvas.height / 2;
    }
}
window.addEventListener('resize', resize);
resize();

// --- INPUT HANDLING ---
const leftZone = document.getElementById('left-zone');
const rightZone = document.getElementById('right-zone');

function handleTouch(e, zoneStr, type) {
    e.preventDefault();
    const stick = input[zoneStr];
    const touch = e.changedTouches[0]; 
    // Usually we track touch IDs, but for simple split screen zones, simple rect check is enough
    
    if (type === 'start') {
        stick.active = true;
        stick.originX = touch.clientX;
        stick.originY = touch.clientY;
        stick.currX = touch.clientX;
        stick.currY = touch.clientY;
        stick.x = 0;
        stick.y = 0;
    } else if (type === 'move' && stick.active) {
        stick.currX = touch.clientX;
        stick.currY = touch.clientY;
        
        let dx = stick.currX - stick.originX;
        let dy = stick.currY - stick.originY;
        const maxDist = 50;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        // Normalize
        if (dist > maxDist) {
            dx = (dx / dist) * maxDist;
            dy = (dy / dist) * maxDist;
        }
        
        stick.x = dx / maxDist;
        stick.y = dy / maxDist;
    } else if (type === 'end') {
        stick.active = false;
        stick.x = 0;
        stick.y = 0;
    }
}

// Attach listeners helper
function attachJoystick(elem, zoneName) {
    elem.addEventListener('touchstart', (e) => handleTouch(e, zoneName, 'start'), {passive: false});
    elem.addEventListener('touchmove', (e) => handleTouch(e, zoneName, 'move'), {passive: false});
    elem.addEventListener('touchend', (e) => handleTouch(e, zoneName, 'end'), {passive: false});
    
    // Mouse fallback for desktop testing
    elem.addEventListener('mousedown', (e) => {
        // Mock touch object
        const mockE = { 
            preventDefault: ()=>{}, 
            changedTouches: [{ clientX: e.clientX, clientY: e.clientY }] 
        };
        handleTouch(mockE, zoneName, 'start');
        
        const moveHandler = (ev) => {
            const mockMove = { 
                preventDefault: ()=>{}, 
                changedTouches: [{ clientX: ev.clientX, clientY: ev.clientY }] 
            };
            handleTouch(mockMove, zoneName, 'move');
        };
        const endHandler = () => {
            handleTouch({ preventDefault: ()=>{}, changedTouches: []}, zoneName, 'end');
            window.removeEventListener('mousemove', moveHandler);
            window.removeEventListener('mouseup', endHandler);
        };
        window.addEventListener('mousemove', moveHandler);
        window.addEventListener('mouseup', endHandler);
    });
}

attachJoystick(leftZone, 'leftStick');
attachJoystick(rightZone, 'rightStick');

// --- GAME LOGIC ---

// Weapon Switching
window.setWeapon = function(type) {
    player.weapon = type;
    document.querySelectorAll('.weapon-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('btn-' + type).classList.add('active');
};

function spawnEnemy() {
    const edge = Math.floor(Math.random() * 4); // 0:top, 1:right, 2:bottom, 3:left
    let ex, ey;
    const buffer = 50;
    
    if (edge === 0) { ex = Math.random() * canvas.width; ey = -buffer; }
    else if (edge === 1) { ex = canvas.width + buffer; ey = Math.random() * canvas.height; }
    else if (edge === 2) { ex = Math.random() * canvas.width; ey = canvas.height + buffer; }
    else { ex = -buffer; ey = Math.random() * canvas.height; }

    enemies.push({
        x: ex,
        y: ey,
        radius: 15,
        hp: 30 + (score * 2), // Difficulty scaling
        speed: 1.5 + (Math.random() * 1),
        maxHp: 30 + (score * 2)
    });
}

function update(dt) {
    if (gameOver) return;

    // 1. Move Player
    if (input.leftStick.active) {
        player.x += input.leftStick.x * player.speed;
        player.y += input.leftStick.y * player.speed;
        
        // Boundaries
        player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
        player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));
    }

    // 2. Aim & Shoot
    if (input.rightStick.active) {
        const rx = input.rightStick.x;
        const ry = input.rightStick.y;
        if (Math.abs(rx) > 0.1 || Math.abs(ry) > 0.1) {
            player.angle = Math.atan2(ry, rx);
            
            // Fire Weapon
            if (player.cooldown <= 0) {
                fireWeapon(rx, ry);
            }
        }
    }
    if (player.cooldown > 0) player.cooldown--;

    // 3. Update Bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        b.x += Math.cos(b.angle) * b.speed;
        b.y += Math.sin(b.angle) * b.speed;
        b.life--;

        // Remove if off screen or dead
        if (b.life <= 0 || b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
            bullets.splice(i, 1);
            continue;
        }

        // Collision with Enemies
        for (let j = enemies.length - 1; j >= 0; j--) {
            let e = enemies[j];
            let dist = Math.hypot(b.x - e.x, b.y - e.y);
            if (dist < e.radius + b.radius) {
                // Hit
                damageEnemy(e, b.damage);
                createParticles(e.x, e.y, b.color, 3);
                
                if (!b.piercing) {
                    bullets.splice(i, 1);
                    break; 
                }
            }
        }
    }

    // 4. Update Enemies
    if (Math.random() < 0.02) spawnEnemy(); // Spawn rate

    for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i];
        
        // Move towards player
        let dx = player.x - e.x;
        let dy = player.y - e.y;
        let dist = Math.hypot(dx, dy);
        
        e.x += (dx / dist) * e.speed;
        e.y += (dy / dist) * e.speed;

        // Collision with Player
        if (dist < player.radius + e.radius) {
            player.hp -= 1; // Damage over time on contact
            createParticles(player.x, player.y, '#f00', 1);
            if (player.hp <= 0) {
                gameOver = true;
                setTimeout(() => location.reload(), 2000);
            }
        }

        if (e.hp <= 0) {
            createParticles(e.x, e.y, '#fff', 8);
            score++;
            enemies.splice(i, 1);
        }
    }

    // 5. Update Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
    }

    // Update HP UI
    const hpPct = Math.max(0, (player.hp / player.maxHp) * 100);
    document.getElementById('hp-bar-fill').style.width = hpPct + "%";
}

function fireWeapon(vx, vy) {
    const config = weapons[player.weapon];
    const angle = Math.atan2(vy, vx);
    
    player.cooldown = config.cooldown;

    if (config.type === 'projectile') {
        bullets.push({
            x: player.x, y: player.y,
            angle: angle,
            speed: config.speed,
            damage: config.damage,
            color: config.color,
            radius: 5,
            life: 100,
            piercing: config.piercing
        });
    } 
    else if (config.type === 'spread') {
        for (let i = -1; i <= 1; i++) {
            bullets.push({
                x: player.x, y: player.y,
                angle: angle + (i * 0.25), // ~15 degrees
                speed: config.speed,
                damage: config.damage,
                color: config.color,
                radius: 4,
                life: 60,
                piercing: false
            });
        }
    }
    else if (config.type === 'instant') {
        // Lightning: Find closest enemy
        let nearest = null;
        let minDist = config.range;
        
        enemies.forEach(e => {
            let d = Math.hypot(e.x - player.x, e.y - player.y);
            if (d < minDist) {
                minDist = d;
                nearest = e;
            }
        });

        if (nearest) {
            damageEnemy(nearest, config.damage);
            // Visual Effect stored in global particles for rendering
            particles.push({
                type: 'lightning',
                sx: player.x, sy: player.y,
                ex: nearest.x, ey: nearest.y,
                life: 5,
                color: config.color
            });
            // Simple Chain (one jump)
            let nextNearest = null;
            let nextMinDist = 200;
            enemies.forEach(e => {
                if (e === nearest) return;
                let d = Math.hypot(e.x - nearest.x, e.y - nearest.y);
                if (d < nextMinDist) {
                    nextMinDist = d;
                    nextNearest = e;
                }
            });
            if (nextNearest) {
                damageEnemy(nextNearest, config.damage / 2);
                particles.push({
                    type: 'lightning',
                    sx: nearest.x, sy: nearest.y,
                    ex: nextNearest.x, ey: nextNearest.y,
                    life: 5,
                    color: config.color
                });
            }
        }
    }
    else if (config.type === 'beam') {
        // Laser logic is mostly visual in Draw, but we apply damage here
        // Raycast logic
        let hit = false;
        let endX = player.x + Math.cos(angle) * config.range;
        let endY = player.y + Math.sin(angle) * config.range;

        // Check intersection with enemies
        for (let e of enemies) {
            // Simple check: distance to line segment
            // (Math omitted for brevity, using simple proximity to beam center)
            // A true raycast against circles is better, but this is a prototype
            let distToPlayer = Math.hypot(e.x - player.x, e.y - player.y);
            if (distToPlayer > config.range) continue;
            
            // Check angular difference
            let angleToEnemy = Math.atan2(e.y - player.y, e.x - player.x);
            let diff = Math.abs(angle - angleToEnemy);
            // Normalize angle diff
            if (diff > Math.PI) diff = 2 * Math.PI - diff;
            
            if (diff < 0.1) { // Very narrow cone
                damageEnemy(e, config.damage);
                createParticles(e.x, e.y, config.color, 1);
            }
        }
        
        // Visual
        particles.push({
            type: 'beam',
            sx: player.x, sy: player.y,
            ex: endX, ey: endY,
            life: 1,
            color: config.color
        });
    }
}

function damageEnemy(e, amt) {
    e.hp -= amt;
    // visual pop
    e.radius = 20; 
}

function createParticles(x, y, color, count) {
    for(let i=0; i<count; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 5,
            vy: (Math.random() - 0.5) * 5,
            life: 20,
            color: color,
            type: 'spark'
        });
    }
}

// --- RENDER ---
function draw() {
    // Clear
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw Joysticks (Visual Feedback)
    if (input.leftStick.active) {
        drawJoy(input.leftStick.originX, input.leftStick.originY, input.leftStick.currX, input.leftStick.currY);
    }
    if (input.rightStick.active) {
        drawJoy(input.rightStick.originX, input.rightStick.originY, input.rightStick.currX, input.rightStick.currY);
    }

    // Draw Player
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(player.angle);
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.moveTo(15, 0); // Nose
    ctx.lineTo(-10, 10);
    ctx.lineTo(-5, 0);
    ctx.lineTo(-10, -10);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // Draw Enemies
    enemies.forEach(e => {
        // Reset radius pop effect
        if(e.radius > 15) e.radius -= 1;
        
        ctx.save();
        ctx.translate(e.x, e.y);
        ctx.strokeStyle = '#f55';
        ctx.lineWidth = 3;
        // Draw X shape
        ctx.beginPath();
        ctx.moveTo(-e.radius/2, -e.radius/2);
        ctx.lineTo(e.radius/2, e.radius/2);
        ctx.moveTo(e.radius/2, -e.radius/2);
        ctx.lineTo(-e.radius/2, e.radius/2);
        ctx.stroke();
        ctx.restore();
    });

    // Draw Bullets
    bullets.forEach(b => {
        ctx.fillStyle = b.color;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
        ctx.fill();
    });

    // Draw Particles / Effects
    particles.forEach(p => {
        ctx.strokeStyle = p.color;
        ctx.lineWidth = 2;
        
        if (p.type === 'spark') {
            ctx.globalAlpha = p.life / 20;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 2, 0, Math.PI*2);
            ctx.stroke();
        } else if (p.type === 'lightning') {
            ctx.globalAlpha = p.life / 5;
            ctx.beginPath();
            ctx.moveTo(p.sx, p.sy);
            // Midpoint jitter
            let midX = (p.sx + p.ex) / 2 + (Math.random()-0.5)*20;
            let midY = (p.sy + p.ey) / 2 + (Math.random()-0.5)*20;
            ctx.lineTo(midX, midY);
            ctx.lineTo(p.ex, p.ey);
            ctx.stroke();
        } else if (p.type === 'beam') {
            ctx.globalAlpha = 0.5;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(p.sx, p.sy);
            ctx.lineTo(p.ex, p.ey);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
    });

    // Game Over Overlay
    if (gameOver) {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(0,0,canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = '40px Arial';
        ctx.textAlign = 'center';
        ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);
        ctx.font = '20px Arial';
        ctx.fillText("Score: " + score, canvas.width/2, canvas.height/2 + 40);
    }
}

function drawJoy(ox, oy, cx, cy) {
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 2;
    // Base
    ctx.beginPath();
    ctx.arc(ox, oy, 50, 0, Math.PI * 2);
    ctx.stroke();
    // Stick
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.beginPath();
    ctx.arc(cx, cy, 20, 0, Math.PI * 2);
    ctx.fill();
}

// --- MAIN LOOP ---
function loop(timestamp) {
    const dt = timestamp - lastTime;
    lastTime = timestamp;

    update(dt);
    draw();
    requestAnimationFrame(loop);
}

requestAnimationFrame(loop);

</script>
</body>
</html>
