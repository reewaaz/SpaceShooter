<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Invaders: Big & Progressive</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Teko:wght@400;600&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050508;
            color: #fff;
            font-family: 'Teko', sans-serif;
            touch-action: none; /* Prevents scroll/zoom on mobile */
            user-select: none;
            cursor: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px 30px;
            font-size: 40px; /* Bigger Text */
            letter-spacing: 2px;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        }

        #score-display { color: #0ff; }
        #difficulty-display { color: #f0f; font-size: 30px; margin-top: 5px; }

        /* Health Bar - Bigger and brighter */
        #health-container {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        #health-fill {
            width: 100%;
            height: 100%;
            background: #0f0;
            box-shadow: 0 0 20px #0f0;
            transition: width 0.2s linear;
        }

        /* --- SCREENS --- */
        .screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 8, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 20;
            cursor: default;
        }

        h1 {
            font-size: 80px; /* Massive Title */
            margin: 0;
            background: linear-gradient(to bottom, #0ff, #f0f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 40px rgba(0, 255, 255, 0.4);
            line-height: 0.9;
            text-align: center;
        }

        p {
            font-size: 22px;
            color: #aaa;
            text-align: center;
            margin-bottom: 40px;
            max-width: 90%;
            line-height: 1.4;
        }

        .btn {
            padding: 20px 60px;
            font-family: 'Teko', sans-serif;
            font-size: 30px;
            color: #0ff;
            background: transparent;
            border: 3px solid #0ff;
            border-radius: 5px;
            text-transform: uppercase;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            cursor: pointer;
        }
        .btn:active { background: #0ff; color: #000; }

        .hidden { display: none !important; }

        /* Mouse Crosshair */
        #crosshair {
            position: absolute;
            width: 40px; height: 40px;
            border: 3px solid #ff0;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none;
            z-index: 15;
            box-shadow: 0 0 15px #ff0;
        }
    </style>
</head>
<body>

    <div id="crosshair"></div>
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="score-display">0</div>
            <div id="difficulty-display">THREAT: LOW</div>
        </div>
        <div id="health-container"><div id="health-fill"></div></div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="screen">
        <h1>NEON<br>TITAN</h1>
        <p>
            SURVIVE THE ESCALATION<br><br>
            <span style="color:#0ff">LEFT TOUCH:</span> MOVE<br>
            <span style="color:#f0f">RIGHT TOUCH:</span> AIM & FIRE
        </p>
        <button class="btn" id="start-btn">START MISSION</button>
    </div>

    <!-- Game Over -->
    <div id="game-over-screen" class="screen hidden">
        <h1 style="background: linear-gradient(to bottom, #f00, #fa0); -webkit-background-clip: text;">KIA</h1>
        <p id="final-score">SCORE: 0</p>
        <button class="btn" id="restart-btn" style="border-color:#f00; color:#f00; box-shadow:0 0 20px #500;">RETRY</button>
    </div>

    <script>
        // --- AUDIO ENGINE (Synthesizer) ---
        const AudioSys = {
            ctx: null,
            init: function() {
                if(!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                if(this.ctx.state === 'suspended') this.ctx.resume();
            },
            play: function(freq, type, dur, vol, slide=false) {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                if(slide) osc.frequency.exponentialRampToValueAtTime(freq/4, this.ctx.currentTime + dur);
                
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + dur);
            },
            shoot: function() { this.play(600, 'sawtooth', 0.15, 0.1, true); },
            hit: function() { this.play(200, 'square', 0.1, 0.1); },
            explode: function() { this.play(100, 'sawtooth', 0.4, 0.2, true); }
        };

        // --- GAME CONFIG & STATE ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        // Settings for "Big Mode"
        const CFG = {
            playerSize: 25,     // Radius
            enemySize: 28,      // Radius
            bulletSize: 6,      // Radius
            joyBase: 70,        // Joystick Base Radius (Big for thumbs)
            joyThumb: 35,       // Joystick Thumb Radius
            baseSpeed: 350,
            colors: { p: '#0ff', e: '#f0f', b: '#ff0' }
        };

        // State
        let gameActive = false;
        let lastTime = 0;
        let gameTime = 0; // Total survival time
        let score = 0;
        
        // Difficulty Variables
        let spawnTimer = 0;
        let currentSpawnRate = 2.5; // Start slow
        let currentEnemySpeed = 60; // Start very slow
        let currentThreatLevel = "LOW";

        // Entities
        const player = { x: 0, y: 0, hp: 100, maxHp: 100, angle: -1.57, cd: 0 };
        let bullets = [];
        let enemies = [];
        let particles = [];
        
        // Input
        const input = {
            keys: {},
            mouse: { x: 0, y: 0, down: false, active: false },
            stickL: { active: false, x: 0, y: 0, ox: 0, oy: 0, id: null },
            stickR: { active: false, x: 0, y: 0, ox: 0, oy: 0, id: null }
        };

        // --- SETUP & RESIZE ---
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if(!gameActive) {
                player.x = canvas.width/2;
                player.y = canvas.height/2;
            }
        }
        window.addEventListener('resize', resize);
        resize();

        // --- DIFFICULTY ENGINE ---
        function updateDifficulty(dt) {
            gameTime += dt;
            
            // 1. Speed Ramp: Increases by 3 pixels/sec every second
            // Starts at 60 (Slow), hits 200 (Fast) after ~45 seconds
            currentEnemySpeed = 60 + (gameTime * 3);
            if(currentEnemySpeed > 350) currentEnemySpeed = 350; // Cap speed

            // 2. Spawn Rate: Drops from 2.5s to 0.4s
            currentSpawnRate = Math.max(0.4, 2.5 - (gameTime * 0.04));

            // 3. UI Update
            let threat = "LOW";
            if(gameTime > 20) threat = "MED";
            if(gameTime > 45) threat = "HIGH";
            if(gameTime > 80) threat = "EXTREME";
            
            if(threat !== currentThreatLevel) {
                currentThreatLevel = threat;
                document.getElementById('difficulty-display').innerText = "THREAT: " + threat;
                // Flash effect
                document.getElementById('difficulty-display').style.color = '#fff';
                setTimeout(() => document.getElementById('difficulty-display').style.color = '#f0f', 200);
            }
        }

        // --- INPUT HANDLING ---
        // Mouse / Keyboard
        window.addEventListener('keydown', e => input.keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => input.keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousemove', e => {
            input.mouse.x = e.clientX; input.mouse.y = e.clientY;
            input.mouse.active = true;
            document.getElementById('crosshair').style.left = e.clientX+'px';
            document.getElementById('crosshair').style.top = e.clientY+'px';
            document.getElementById('crosshair').style.display = 'block';
        });
        window.addEventListener('mousedown', () => input.mouse.down = true);
        window.addEventListener('mouseup', () => input.mouse.down = false);

        // Touch (Twin Stick)
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            input.mouse.active = false;
            document.getElementById('crosshair').style.display = 'none';
            
            for(let i=0; i<e.changedTouches.length; i++) {
                let t = e.changedTouches[i];
                // Split screen logic
                if(t.clientX < canvas.width/2) {
                    input.stickL.active = true;
                    input.stickL.id = t.identifier;
                    input.stickL.ox = t.clientX; input.stickL.oy = t.clientY;
                    input.stickL.x = 0; input.stickL.y = 0;
                } else {
                    input.stickR.active = true;
                    input.stickR.id = t.identifier;
                    input.stickR.ox = t.clientX; input.stickR.oy = t.clientY;
                    input.stickR.x = 0; input.stickR.y = 0;
                }
            }
        }, {passive: false});

        const handleTouchMove = (e) => {
            e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++) {
                let t = e.changedTouches[i];
                if(input.stickL.id === t.identifier) updateStick(input.stickL, t);
                if(input.stickR.id === t.identifier) updateStick(input.stickR, t);
            }
        };
        canvas.addEventListener('touchmove', handleTouchMove, {passive: false});

        const handleTouchEnd = (e) => {
            e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++) {
                let t = e.changedTouches[i];
                if(input.stickL.id === t.identifier) input.stickL.active = false;
                if(input.stickR.id === t.identifier) input.stickR.active = false;
            }
        };
        canvas.addEventListener('touchend', handleTouchEnd);
        canvas.addEventListener('touchcancel', handleTouchEnd);

        function updateStick(stick, t) {
            let dx = t.clientX - stick.ox;
            let dy = t.clientY - stick.oy;
            let dist = Math.hypot(dx, dy);
            let angle = Math.atan2(dy, dx);
            let limit = Math.min(dist, CFG.joyBase); // Cap visual movement
            
            // Normalize -1 to 1
            stick.x = (Math.cos(angle) * limit) / CFG.joyBase;
            stick.y = (Math.sin(angle) * limit) / CFG.joyBase;
        }

        // --- GAME LOOP ---
        function update(dt) {
            updateDifficulty(dt);

            // 1. Player Move
            let dx = 0, dy = 0;
            if(input.keys['w']) dy = -1;
            if(input.keys['s']) dy = 1;
            if(input.keys['a']) dx = -1;
            if(input.keys['d']) dx = 1;
            if(input.stickL.active) { dx = input.stickL.x; dy = input.stickL.y; }

            // Apply Move
            let len = Math.hypot(dx, dy);
            if(len > 0.1) {
                if(len > 1) len = 1;
                player.x += (dx/len) * CFG.baseSpeed * len * dt;
                player.y += (dy/len) * CFG.baseSpeed * len * dt;
            }
            // Clamp
            player.x = Math.max(CFG.playerSize, Math.min(canvas.width - CFG.playerSize, player.x));
            player.y = Math.max(CFG.playerSize, Math.min(canvas.height - CFG.playerSize, player.y));

            // 2. Aim & Shoot
            let aimX=0, aimY=0, shoot=false;
            if(input.mouse.active) {
                aimX = input.mouse.x - player.x;
                aimY = input.mouse.y - player.y;
                player.angle = Math.atan2(aimY, aimX);
                shoot = input.mouse.down;
            } else if(input.stickR.active) {
                // Deadzone check
                if(Math.hypot(input.stickR.x, input.stickR.y) > 0.2) {
                    player.angle = Math.atan2(input.stickR.y, input.stickR.x);
                    shoot = true;
                }
            }

            player.cd -= dt;
            if(shoot && player.cd <= 0) {
                // Fire
                bullets.push({
                    x: player.x + Math.cos(player.angle)*30,
                    y: player.y + Math.sin(player.angle)*30,
                    vx: Math.cos(player.angle) * 900,
                    vy: Math.sin(player.angle) * 900
                });
                player.cd = 0.12;
                // Pushback
                player.x -= Math.cos(player.angle) * 3;
                player.y -= Math.sin(player.angle) * 3;
                AudioSys.shoot();
            }

            // 3. Bullets
            for(let i=bullets.length-1; i>=0; i--) {
                let b = bullets[i];
                b.x += b.vx * dt;
                b.y += b.vy * dt;
                if(b.x < -50 || b.x > canvas.width+50 || b.y < -50 || b.y > canvas.height+50) {
                    bullets.splice(i,1); continue;
                }
                
                // Hit check
                for(let j=enemies.length-1; j>=0; j--) {
                    let e = enemies[j];
                    let dist = Math.hypot(b.x - e.x, b.y - e.y);
                    if(dist < CFG.enemySize + CFG.bulletSize) {
                        e.hp--;
                        bullets.splice(i,1);
                        AudioSys.hit();
                        createParticles(b.x, b.y, CFG.colors.b, 3);
                        if(e.hp <= 0) {
                            killEnemy(j);
                        }
                        break;
                    }
                }
            }

            // 4. Enemy Spawning
            spawnTimer -= dt;
            if(spawnTimer <= 0) {
                spawnEnemy();
                spawnTimer = currentSpawnRate;
            }

            // 5. Enemy Update
            enemies.forEach(e => {
                let angle = Math.atan2(player.y - e.y, player.x - e.x);
                // Swarm Logic
                e.x += Math.cos(angle) * currentEnemySpeed * dt;
                e.y += Math.sin(angle) * currentEnemySpeed * dt;
                e.angle = angle;

                // Hit Player
                let dist = Math.hypot(player.x - e.x, player.y - e.y);
                if(dist < CFG.playerSize + CFG.enemySize - 5) {
                    player.hp -= 30 * dt;
                    updateHealth();
                    if(player.hp <= 0) gameOver();
                }
            });

            // 6. Particles
            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.life -= dt * 2;
                if(p.life <= 0) particles.splice(i,1);
            }
        }

        function spawnEnemy() {
            // Determine side
            let x, y;
            if(Math.random() > 0.5) {
                x = Math.random() > 0.5 ? -50 : canvas.width + 50;
                y = Math.random() * canvas.height;
            } else {
                x = Math.random() * canvas.width;
                y = Math.random() > 0.5 ? -50 : canvas.height + 50;
            }

            // HP scales with game time (Every 30s, +1 HP)
            let extraHp = Math.floor(gameTime / 30);
            
            enemies.push({
                x: x, y: y,
                hp: 1 + extraHp,
                maxHp: 1 + extraHp,
                angle: 0
            });
        }

        function killEnemy(idx) {
            let e = enemies[idx];
            createParticles(e.x, e.y, CFG.colors.e, 10);
            enemies.splice(idx, 1);
            score += 100;
            document.getElementById('score-display').innerText = score;
            AudioSys.explode();
        }

        function createParticles(x, y, color, count) {
            for(let i=0; i<count; i++) {
                let a = Math.random() * 6.28;
                let s = Math.random() * 150;
                particles.push({
                    x: x, y: y,
                    vx: Math.cos(a)*s, vy: Math.sin(a)*s,
                    color: color, life: 1
                });
            }
        }

        // --- DRAW ---
        function draw() {
            // Background
            ctx.fillStyle = '#050508';
            ctx.fillRect(0,0, canvas.width, canvas.height);
            
            // Grid
            ctx.strokeStyle = '#111';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for(let x=0; x<canvas.width; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
            for(let y=0; y<canvas.height; y+=50) { ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
            ctx.stroke();

            // Setup Glow
            ctx.shadowBlur = 25; // High glow for big sprites

            // Player
            ctx.shadowColor = CFG.colors.p;
            ctx.fillStyle = '#000';
            ctx.strokeStyle = CFG.colors.p;
            ctx.lineWidth = 4;
            
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);
            ctx.beginPath();
            // Larger Ship Shape
            ctx.moveTo(CFG.playerSize, 0);
            ctx.lineTo(-CFG.playerSize, CFG.playerSize);
            ctx.lineTo(-CFG.playerSize/2, 0);
            ctx.lineTo(-CFG.playerSize, -CFG.playerSize);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();

            // Enemies
            ctx.shadowColor = CFG.colors.e;
            ctx.strokeStyle = CFG.colors.e;
            ctx.lineWidth = 3;
            enemies.forEach(e => {
                ctx.save();
                ctx.translate(e.x, e.y);
                ctx.rotate(e.angle);
                ctx.fillStyle = '#101';
                ctx.beginPath();
                // Big Hexagon
                for(let i=0; i<6; i++) {
                    let a = (Math.PI/3)*i;
                    ctx.lineTo(Math.cos(a)*CFG.enemySize, Math.sin(a)*CFG.enemySize);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                // Inner Eye
                ctx.fillStyle = '#f0f';
                ctx.beginPath();
                ctx.arc(0,0, 8, 0, 6.28);
                ctx.fill();
                ctx.restore();
            });

            // Bullets
            ctx.shadowColor = CFG.colors.b;
            ctx.fillStyle = CFG.colors.b;
            bullets.forEach(b => {
                ctx.beginPath();
                ctx.arc(b.x, b.y, CFG.bulletSize, 0, 6.28);
                ctx.fill();
            });

            // Particles
            ctx.shadowBlur = 10;
            particles.forEach(p => {
                ctx.shadowColor = p.color;
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, 6.28);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Joysticks
            drawJoy(input.stickL, '#0ff');
            drawJoy(input.stickR, '#f0f');
        }

        function drawJoy(stick, col) {
            if(!stick.active) return;
            ctx.shadowBlur = 0;
            ctx.strokeStyle = col;
            ctx.lineWidth = 3;
            // Base
            ctx.beginPath();
            ctx.arc(stick.ox, stick.oy, CFG.joyBase, 0, 6.28);
            ctx.stroke();
            // Thumb
            ctx.fillStyle = col;
            ctx.globalAlpha = 0.5;
            ctx.beginPath();
            ctx.arc(stick.ox + stick.x*CFG.joyBase, stick.oy + stick.y*CFG.joyBase, CFG.joyThumb, 0, 6.28);
            ctx.fill();
            ctx.globalAlpha = 1;
        }

        // --- CORE ---
        function loop(ts) {
            if(!gameActive) return;
            const dt = (ts - lastTime) / 1000;
            lastTime = ts;
            update(dt);
            draw();
            requestAnimationFrame(loop);
        }

        function startGame() {
            AudioSys.init();
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            
            // Reset
            gameActive = true;
            score = 0;
            gameTime = 0;
            spawnTimer = 0;
            player.hp = 100;
            player.x = canvas.width/2;
            player.y = canvas.height/2;
            enemies = [];
            bullets = [];
            particles = [];
            
            // Reset UI
            document.getElementById('score-display').innerText = "0";
            document.getElementById('difficulty-display').innerText = "THREAT: LOW";
            updateHealth();

            lastTime = performance.now();
            requestAnimationFrame(loop);
        }

        function updateHealth() {
            const pct = Math.max(0, player.hp);
            const bar = document.getElementById('health-fill');
            bar.style.width = pct + '%';
            if(pct < 30) bar.style.background = '#f00';
            else bar.style.background = '#0f0';
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('final-score').innerText = "FINAL SCORE: " + score;
            document.getElementById('game-over-screen').classList.remove('hidden');
        }

        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('restart-btn').addEventListener('click', startGame);

    </script>
</body>
</html>
