<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Space Defender: Earth's Last Stand</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }

        #gameCanvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            font-size: 20px;
            text-shadow: 0 0 10px #0ff;
        }

        .weapon-wheel {
            position: absolute;
            bottom: 30px;
            right: 30px;
            text-align: right;
        }

        .weapon-slot {
            font-size: 16px;
            color: #555;
            margin: 5px 0;
            transition: 0.3s;
        }

        .weapon-slot.active {
            color: #0f0;
            font-size: 22px;
            text-shadow: 0 0 10px #0f0;
            font-weight: bold;
        }

        #menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            z-index: 10;
        }

        h1 {
            font-size: 60px;
            color: #fff;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #0000ff;
            margin-bottom: 10px;
            text-align: center;
        }

        .btn {
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            padding: 15px 40px;
            font-size: 24px;
            margin: 10px;
            cursor: pointer;
            font-family: inherit;
            transition: 0.2s;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        }

        .btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
        }

        .instructions {
            margin-top: 30px;
            color: #aaa;
            text-align: center;
            line-height: 1.6;
            max-width: 600px;
        }

        .key {
            border: 1px solid #666;
            padding: 2px 6px;
            border-radius: 4px;
            color: #fff;
            background: #222;
        }
    </style>
</head>
<body>

    <!-- Game UI -->
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div class="hud-top">
            <div id="scoreDisplay">SCORE: 0</div>
            <div id="waveDisplay">WAVE: 1</div>
            <div id="healthDisplay">HP: 100%</div>
        </div>
        
        <div class="weapon-wheel" id="weaponWheel">
            <!-- Populated by JS -->
        </div>
    </div>

    <!-- Menus -->
    <div id="menu-screen">
        <h1>NEON DEFENDER</h1>
        <p style="color:#f0f; text-shadow:0 0 10px #f0f;">PROTECT THE EARTH</p>
        <button class="btn" onclick="startGame(1)">SINGLE PLAYER</button>
        <button class="btn" onclick="startGame(2)">LOCAL CO-OP (2 Players)</button>
        
        <div class="instructions">
            <p><strong>P1 Controls:</strong> <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> to Move | Mouse to Aim & Shoot | <span class="key">1</span>-<span class="key">3</span> Switch Weapon</p>
            <p id="p2-controls" style="display:none;"><strong>P2 Controls:</strong> <span class="key">ARROWS</span> to Move | <span class="key">NUMPAD 0</span> or <span class="key">M</span> to Shoot</p>
            <p>Destroy aliens. Collect colored orbs for weapons & health.</p>
        </div>
    </div>

<script>
/** 
 * GAME ENGINE & LOGIC
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiLayer = document.getElementById('ui-layer');
const menuScreen = document.getElementById('menu-screen');
const scoreDisplay = document.getElementById('scoreDisplay');
const healthDisplay = document.getElementById('healthDisplay');
const waveDisplay = document.getElementById('waveDisplay');
const weaponWheel = document.getElementById('weaponWheel');

// Set Canvas Size
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// --- AUDIO SYSTEM (Web Audio API) ---
const AudioContext = window.AudioContext || window.webkitAudioContext;
const actx = new AudioContext();

const Sound = {
    shoot: (freq = 400, type = 'square') => {
        if(actx.state === 'suspended') actx.resume();
        const osc = actx.createOscillator();
        const gain = actx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, actx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq/4, actx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, actx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, actx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(actx.destination);
        osc.start();
        osc.stop(actx.currentTime + 0.15);
    },
    explode: () => {
        if(actx.state === 'suspended') actx.resume();
        const bufferSize = actx.sampleRate * 0.5;
        const buffer = actx.createBuffer(1, bufferSize, actx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        
        const noise = actx.createBufferSource();
        noise.buffer = buffer;
        const gain = actx.createGain();
        gain.gain.setValueAtTime(0.2, actx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, actx.currentTime + 0.5);
        noise.connect(gain);
        gain.connect(actx.destination);
        noise.start();
    },
    powerup: () => {
        if(actx.state === 'suspended') actx.resume();
        const osc = actx.createOscillator();
        const gain = actx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, actx.currentTime);
        osc.frequency.linearRampToValueAtTime(1200, actx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.1, actx.currentTime);
        gain.gain.linearRampToValueAtTime(0, actx.currentTime + 0.3);
        osc.connect(gain);
        gain.connect(actx.destination);
        osc.start();
        osc.stop(actx.currentTime + 0.3);
    }
};

// --- GAME STATE ---
let gameRunning = false;
let playerCount = 1;
let score = 0;
let wave = 1;
let frame = 0;
let shakeTime = 0;

// Entities
let players = [];
let bullets = [];
let enemies = [];
let particles = [];
let powerups = [];

// Input State
const keys = {};
const mouse = { x: 0, y: 0, down: false };

window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
window.addEventListener('mousedown', () => mouse.down = true);
window.addEventListener('mouseup', () => mouse.down = false);

// --- CLASSES ---

class Particle {
    constructor(x, y, color, speed) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const velocity = Math.random() * speed;
        this.vx = Math.cos(angle) * velocity;
        this.vy = Math.sin(angle) * velocity;
        this.life = 1.0;
        this.decay = Math.random() * 0.03 + 0.01;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
    }
    draw() {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class Bullet {
    constructor(x, y, angle, speed, color, damage, owner) {
        this.x = x;
        this.y = y;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.color = color;
        this.damage = damage;
        this.owner = owner; // 'player' or 'enemy'
        this.markedForDeletion = false;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        
        // Screen bounds deletion
        if(this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
            this.markedForDeletion = true;
        }

        // Particle trail
        if (Math.random() > 0.5) {
            particles.push(new Particle(this.x, this.y, this.color, 0.5));
        }
    }
    draw() {
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

class PowerUp {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; // 0: Health, 1: Spread, 2: Rapid
        this.radius = 15;
        this.angle = 0;
    }
    update() {
        this.angle += 0.05;
        this.y += Math.sin(this.angle) * 0.5;
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        let color = '#0f0'; // Health
        let char = '+';
        if(this.type === 1) { color = '#0ff'; char = 'S'; } // Spread
        if(this.type === 2) { color = '#f0f'; char = 'R'; } // Rapid

        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.strokeRect(-10, -10, 20, 20);
        
        ctx.fillStyle = color;
        ctx.font = "bold 16px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(char, 0, 0);
        
        ctx.restore();
    }
}

class Player {
    constructor(id) {
        this.id = id;
        this.x = canvas.width / 2 + (id === 1 ? -50 : 50);
        this.y = canvas.height / 2;
        this.angle = 0;
        this.health = 100;
        this.speed = 5;
        this.weapon = 0; // 0: Blaster, 1: Spread, 2: Rapid
        this.lastShot = 0;
        this.color = id === 1 ? '#0ff' : '#ff0';
        this.fireRate = 15; // Frames between shots
    }

    update() {
        // Movement Logic
        let dx = 0;
        let dy = 0;

        if (this.id === 1) {
            // WASD
            if (keys['KeyW']) dy = -1;
            if (keys['KeyS']) dy = 1;
            if (keys['KeyA']) dx = -1;
            if (keys['KeyD']) dx = 1;
            
            // Aim at mouse
            this.angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);

            // Weapon Switch
            if(keys['Digit1']) this.weapon = 0;
            if(keys['Digit2']) this.weapon = 1;
            if(keys['Digit3']) this.weapon = 2;
            
            // Fire
            if (mouse.down && frame - this.lastShot > this.fireRate) {
                this.shoot();
            }
        } else {
            // Player 2 - Arrows
            if (keys['ArrowUp']) dy = -1;
            if (keys['ArrowDown']) dy = 1;
            if (keys['ArrowLeft']) dx = -1;
            if (keys['ArrowRight']) dx = 1;

            // Simple rotation based on movement or auto-aim nearest enemy (simplified to face movement)
            if (dx !== 0 || dy !== 0) this.angle = Math.atan2(dy, dx);
            
            // Fire
            if ((keys['Numpad0'] || keys['KeyM']) && frame - this.lastShot > this.fireRate) {
                this.shoot();
            }
        }

        // Normalize speed
        if (dx !== 0 || dy !== 0) {
            const len = Math.sqrt(dx*dx + dy*dy);
            this.x += (dx / len) * this.speed;
            this.y += (dy / len) * this.speed;
        }

        // Boundaries
        this.x = Math.max(20, Math.min(canvas.width - 20, this.x));
        this.y = Math.max(20, Math.min(canvas.height - 20, this.y));

        // Weapon Config Update
        if (this.weapon === 0) this.fireRate = 15;
        if (this.weapon === 1) this.fireRate = 25;
        if (this.weapon === 2) this.fireRate = 5;

        this.updateUI();
    }

    shoot() {
        this.lastShot = frame;
        Sound.shoot(this.weapon === 2 ? 600 : 400);

        if (this.weapon === 0) { // Standard
            bullets.push(new Bullet(this.x, this.y, this.angle, 12, this.color, 20, 'player'));
        } else if (this.weapon === 1) { // Spread
            for(let i = -0.3; i <= 0.3; i+= 0.3) {
                bullets.push(new Bullet(this.x, this.y, this.angle + i, 12, this.color, 15, 'player'));
            }
        } else if (this.weapon === 2) { // Rapid
            const offset = (Math.random() - 0.5) * 0.2;
            bullets.push(new Bullet(this.x, this.y, this.angle + offset, 15, this.color, 8, 'player'));
        }
    }

    updateUI() {
        if (this.id === 1) {
            healthDisplay.innerText = `HP: ${Math.floor(this.health)}%`;
            healthDisplay.style.color = this.health < 30 ? 'red' : '#fff';
            
            // Highlight weapon wheel
            const slots = document.querySelectorAll('.weapon-slot');
            slots.forEach((s, i) => {
                if(i === this.weapon) s.classList.add('active');
                else s.classList.remove('active');
            });
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        
        // Ship Body
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(15, 0);
        ctx.lineTo(-10, 10);
        ctx.lineTo(-5, 0);
        ctx.lineTo(-10, -10);
        ctx.closePath();
        ctx.stroke();

        // Engine flame
        if (this.id === 1 ? (keys['KeyW'] || keys['KeyA'] || keys['KeyS'] || keys['KeyD']) : (keys['ArrowUp'] || keys['ArrowDown'])) {
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.moveTo(-8, 0);
            ctx.lineTo(-18, 5);
            ctx.lineTo(-18, -5);
            ctx.fill();
        }

        ctx.restore();
    }
}

class Enemy {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; // 1: Chaser, 2: Shooter
        this.health = type === 1 ? 30 : 50;
        this.radius = 15;
        this.angle = 0;
        this.markedForDeletion = false;
        this.lastShot = 0;
    }

    update() {
        // Find nearest player
        let target = players[0];
        let minDist = 99999;
        players.forEach(p => {
            const d = Math.hypot(p.x - this.x, p.y - this.y);
            if (d < minDist) {
                minDist = d;
                target = p;
            }
        });

        if (!target) return;

        this.angle = Math.atan2(target.y - this.y, target.x - this.x);

        // Move
        const speed = this.type === 1 ? 3 : 1.5;
        this.x += Math.cos(this.angle) * speed;
        this.y += Math.sin(this.angle) * speed;

        // Shooter Logic
        if (this.type === 2) {
            if (frame - this.lastShot > 100 && minDist < 400) {
                bullets.push(new Bullet(this.x, this.y, this.angle, 6, '#f00', 10, 'enemy'));
                Sound.shoot(200, 'sawtooth');
                this.lastShot = frame;
            }
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#f00';
        ctx.strokeStyle = '#f00';
        ctx.lineWidth = 2;

        ctx.beginPath();
        if (this.type === 1) { // Triangle Chaser
            ctx.moveTo(10, 0);
            ctx.lineTo(-10, 8);
            ctx.lineTo(-10, -8);
        } else { // Square Shooter
            ctx.rect(-10, -10, 20, 20);
        }
        ctx.closePath();
        ctx.stroke();

        ctx.restore();
    }
}

// --- CORE FUNCTIONS ---

function spawnEnemy() {
    const edge = Math.floor(Math.random() * 4); // 0:top, 1:right, 2:bottom, 3:left
    let x, y;
    
    if (edge === 0) { x = Math.random() * canvas.width; y = -30; }
    if (edge === 1) { x = canvas.width + 30; y = Math.random() * canvas.height; }
    if (edge === 2) { x = Math.random() * canvas.width; y = canvas.height + 30; }
    if (edge === 3) { x = -30; y = Math.random() * canvas.height; }

    // Difficulty scaling
    const type = Math.random() < 0.3 + (wave * 0.05) ? 2 : 1; 
    enemies.push(new Enemy(x, y, type));
}

function checkCollisions() {
    // Bullets vs Enemies / Players
    bullets.forEach(b => {
        if (b.owner === 'player') {
            enemies.forEach(e => {
                const dist = Math.hypot(b.x - e.x, b.y - e.y);
                if (dist < e.radius + 3) {
                    b.markedForDeletion = true;
                    e.health -= b.damage;
                    // Spark effects
                    for(let i=0; i<3; i++) particles.push(new Particle(b.x, b.y, b.color, 2));
                    
                    if (e.health <= 0) {
                        e.markedForDeletion = true;
                        Sound.explode();
                        score += 100;
                        scoreDisplay.innerText = `SCORE: ${score}`;
                        // Explosion particles
                        for(let i=0; i<15; i++) particles.push(new Particle(e.x, e.y, '#f00', 4));
                        // Loot drop (10% chance)
                        if(Math.random() < 0.15) {
                            powerups.push(new PowerUp(e.x, e.y, Math.floor(Math.random() * 3)));
                        }
                    }
                }
            });
        } else {
            players.forEach(p => {
                const dist = Math.hypot(b.x - p.x, b.y - p.y);
                if (dist < 15) {
                    b.markedForDeletion = true;
                    p.health -= 10;
                    shakeTime = 10;
                    Sound.explode();
                }
            });
        }
    });

    // Players vs Powerups
    players.forEach(p => {
        powerups.forEach(pu => {
            const dist = Math.hypot(p.x - pu.x, p.y - pu.y);
            if (dist < 20) {
                Sound.powerup();
                if (pu.type === 0) p.health = Math.min(100, p.health + 30);
                else p.weapon = pu.type;
                
                // Remove powerup
                const index = powerups.indexOf(pu);
                powerups.splice(index, 1);
                
                // Floating text effect (visual only, simplified)
                score += 50;
            }
        });
    });

    // Check Player Death
    players.forEach(p => {
        if (p.health <= 0) {
            gameOver();
        }
    });
}

function drawBackground() {
    // Simple starfield
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Grid effect
    ctx.strokeStyle = '#001133';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let x = 0; x < canvas.width; x += 50) {
        ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height);
    }
    for (let y = 0; y < canvas.height; y += 50) {
        ctx.moveTo(0, y); ctx.lineTo(canvas.width, y);
    }
    ctx.stroke();
}

function gameLoop() {
    if (!gameRunning) return;

    // Screen Shake
    if (shakeTime > 0) {
        const dx = Math.random() * 10 - 5;
        const dy = Math.random() * 10 - 5;
        ctx.translate(dx, dy);
        shakeTime--;
    }

    drawBackground();

    // Spawn Logic
    if (frame % (100 - Math.min(50, wave * 5)) === 0) {
        spawnEnemy();
    }
    
    // Wave Logic
    if (score > wave * 1000) {
        wave++;
        waveDisplay.innerText = "WAVE: " + wave;
        // Heal players slightly on wave clear
        players.forEach(p => p.health = Math.min(100, p.health + 20));
    }

    // Update & Draw Entities
    powerups.forEach(p => { p.update(); p.draw(); });
    
    players.forEach(p => { p.update(); p.draw(); });
    
    bullets.forEach((b, index) => {
        b.update();
        b.draw();
        if (b.markedForDeletion) bullets.splice(index, 1);
    });

    enemies.forEach((e, index) => {
        e.update();
        e.draw();
        if (e.markedForDeletion) enemies.splice(index, 1);
    });

    particles.forEach((p, index) => {
        p.update();
        p.draw();
        if (p.life <= 0) particles.splice(index, 1);
    });

    checkCollisions();

    // Reset Matrix for Shake
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    frame++;
    requestAnimationFrame(gameLoop);
}

function initWeaponWheel() {
    weaponWheel.innerHTML = `
        <div class="weapon-slot active">1. BLASTER</div>
        <div class="weapon-slot">2. SPREAD</div>
        <div class="weapon-slot">3. RAPID</div>
    `;
}

function startGame(mode) {
    playerCount = mode;
    players = [];
    enemies = [];
    bullets = [];
    particles = [];
    powerups = [];
    score = 0;
    wave = 1;
    frame = 0;
    
    players.push(new Player(1));
    if (mode === 2) {
        players.push(new Player(2));
        document.getElementById('p2-controls').style.display = 'block';
    }

    initWeaponWheel();
    scoreDisplay.innerText = "SCORE: 0";
    waveDisplay.innerText = "WAVE: 1";
    healthDisplay.innerText = "HP: 100%";
    
    menuScreen.style.display = 'none';
    uiLayer.style.display = 'flex';
    gameRunning = true;
    
    // Start Audio Context on user gesture
    if(actx.state === 'suspended') actx.resume();
    
    gameLoop();
}

function gameOver() {
    gameRunning = false;
    menuScreen.style.display = 'flex';
    menuScreen.querySelector('h1').innerText = "GAME OVER";
    menuScreen.querySelector('p').innerText = `Final Score: ${score} - Waves Survived: ${wave}`;
}

</script>
</body>
</html>
