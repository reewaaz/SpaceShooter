<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Alien Invasion</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            font-family: 'Courier New', Courier, monospace;
            color: white;
            touch-action: none; /* Prevents pull-to-refresh on mobile */
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        #lobby {
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 10px;
            pointer-events: auto;
            border: 2px solid #00ffcc;
            max-width: 90%;
        }
        h1 { margin: 0 0 10px 0; color: #00ffcc; text-transform: uppercase; }
        p { font-size: 14px; color: #ccc; }
        #qrcode { margin: 20px auto; background: white; padding: 10px; display: inline-block; }
        .hidden { display: none !important; }
        #score-board {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 20px;
            font-weight: bold;
            color: white;
            z-index: 10;
        }
        #status {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            font-size: 12px;
            color: #666;
        }
        .btn {
            background: #ff0055;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 5px;
            margin-top: 10px;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <div id="score-board">SCORE: 0</div>
    <div id="status">Initializing...</div>

    <div id="ui-layer">
        <div id="lobby">
            <h1>Alien Invasion</h1>
            <div id="host-ui">
                <p>Scan to join Player 1 (Red)</p>
                <div id="qrcode"></div>
                <p>Waiting for Player 2...</p>
            </div>
            <div id="client-ui" class="hidden">
                <p>Connecting to Host...</p>
            </div>
            <div id="game-over-ui" class="hidden">
                <h1 style="color: #ff0055;">GAME OVER</h1>
                <p id="final-score">Score: 0</p>
                <button class="btn" onclick="location.reload()">RESTART</button>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * GAME CONFIGURATION & STATE
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width, height;

// Resize handling
function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
}
window.addEventListener('resize', resize);
resize();

// Network State
let peer = null;
let conn = null;
const urlParams = new URLSearchParams(window.location.search);
const hostIdParam = urlParams.get('id');
const isHost = !hostIdParam;
let isConnected = false;

// Game State
let gameRunning = false;
let score = 0;
let frames = 0;

// Entities
const players = {
    p1: { x: 0, y: 0, color: '#ff4d4d', active: true, hp: 3, weaponLevel: 1 }, // Host
    p2: { x: 0, y: 0, color: '#4d4dff', active: false, hp: 3, weaponLevel: 1 } // Client
};
let bullets = [];
let enemies = [];
let particles = [];
let powerups = [];

// Input State
const input = { x: 0, y: 0, firing: false }; // Local input

/**
 * NETWORKING (PeerJS)
 */
function initNetwork() {
    peer = new Peer(null, { debug: 2 });

    peer.on('open', (id) => {
        document.getElementById('status').innerText = isHost ? "Hosting ID: " + id : "Connected as Client";
        
        if (isHost) {
            // Generate QR Code
            const gameUrl = `${window.location.protocol}//${window.location.host}${window.location.pathname}?id=${id}`;
            new QRCode(document.getElementById("qrcode"), {
                text: gameUrl,
                width: 180,
                height: 180
            });
            
            // Listen for connection
            peer.on('connection', (c) => {
                conn = c;
                setupConnection();
                players.p2.active = true;
                startGame();
            });
        } else {
            // Connect to host
            document.getElementById('host-ui').classList.add('hidden');
            document.getElementById('client-ui').classList.remove('hidden');
            conn = peer.connect(hostIdParam);
            setupConnection();
        }
    });
}

function setupConnection() {
    conn.on('open', () => {
        isConnected = true;
        document.getElementById('lobby').classList.add('hidden');
        
        // Data Listener
        conn.on('data', (data) => {
            if (isHost) {
                // Host receives input from Client
                if (data.type === 'input') {
                    players.p2.x = data.x * width; // Normalize back to screen size
                    players.p2.y = data.y * height;
                }
            } else {
                // Client receives Game State from Host
                if (data.type === 'state') {
                    players.p1.x = data.p1.x * width;
                    players.p1.y = data.p1.y * height;
                    players.p1.active = data.p1.active;
                    
                    players.p2.x = data.p2.x * width; // Sync own position for smoothness
                    players.p2.y = data.p2.y * height;
                    players.p2.active = data.p2.active;

                    // Sync lists (simplified for bandwidth)
                    bullets = data.bullets; 
                    enemies = data.enemies;
                    powerups = data.powerups;
                    score = data.score;
                    if(data.gameOver) showGameOver();
                }
            }
        });
    });
}

/**
 * INPUT HANDLING (Touch)
 */
canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    input.x = touch.clientX;
    input.y = touch.clientY - 50; // Offset slightly above finger
    input.firing = true;
}, { passive: false });

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    input.x = touch.clientX;
    input.y = touch.clientY - 50;
    input.firing = true;
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    input.firing = false;
});

// Fallback for desktop testing
canvas.addEventListener('mousemove', (e) => {
    if(e.buttons === 1) {
        input.x = e.clientX;
        input.y = e.clientY;
        input.firing = true;
    } else {
        input.firing = false;
    }
});


/**
 * GAME LOGIC
 */
function startGame() {
    gameRunning = true;
    // Reset positions
    players.p1.x = width / 2;
    players.p1.y = height - 100;
    if(!isHost) {
        // Client starts logic instantly, but relies on host for true state
        document.getElementById('lobby').classList.add('hidden');
    }
    loop();
}

function showGameOver() {
    gameRunning = false;
    document.getElementById('ui-layer').style.pointerEvents = 'auto';
    document.getElementById('lobby').classList.remove('hidden');
    document.getElementById('host-ui').classList.add('hidden');
    document.getElementById('client-ui').classList.add('hidden');
    document.getElementById('game-over-ui').classList.remove('hidden');
    document.getElementById('final-score').innerText = "Final Score: " + score;
}

function spawnEnemy() {
    const size = 30 + Math.random() * 20;
    enemies.push({
        x: Math.random() * (width - size),
        y: -size,
        w: size,
        h: size,
        hp: Math.floor(1 + score / 500),
        speed: 2 + Math.random() * 2 + (score/2000)
    });
}

function spawnPowerup(x, y) {
    const types = ['spread', 'speed'];
    const type = types[Math.floor(Math.random() * types.length)];
    powerups.push({
        x: x, y: y, r: 10, type: type, vy: 2,
        color: type === 'spread' ? '#ffff00' : '#00ff00'
    });
}

function fireBullet(playerKey) {
    const p = players[playerKey];
    if (!p.active) return;
    
    // Simple cooldown based on frame check inside update is handled by randomness or timer usually, 
    // but here we just fire every 10 frames to keep code short
    if (frames % 10 === 0) {
        if (p.weaponLevel === 1) {
            bullets.push({ x: p.x, y: p.y - 20, vx: 0, vy: -10, color: p.color, owner: playerKey });
        } else {
            // Spread shot
            bullets.push({ x: p.x, y: p.y - 20, vx: 0, vy: -10, color: p.color, owner: playerKey });
            bullets.push({ x: p.x, y: p.y - 20, vx: -3, vy: -9, color: p.color, owner: playerKey });
            bullets.push({ x: p.x, y: p.y - 20, vx: 3, vy: -9, color: p.color, owner: playerKey });
        }
    }
}

function update() {
    if (!gameRunning) return;
    frames++;

    // --- HOST LOGIC ---
    if (isHost) {
        // Update Player 1 (Host) Input
        if (input.firing) {
            players.p1.x += (input.x - players.p1.x) * 0.2;
            players.p1.y += (input.y - players.p1.y) * 0.2;
            fireBullet('p1');
        }

        // Auto-fire for P2 if connected
        if (players.p2.active && frames % 10 === 0) fireBullet('p2');

        // Spawn Enemies
        if (frames % 60 === 0) spawnEnemy();

        // Update Bullets
        bullets = bullets.filter(b => b.y > -50 && b.y < height && b.x > -50 && b.x < width + 50);
        bullets.forEach(b => {
            b.x += b.vx;
            b.y += b.vy;
        });

        // Update Enemies
        enemies.forEach((e, ei) => {
            e.y += e.speed;
            
            // Collision: Enemy vs Bullets
            bullets.forEach((b, bi) => {
                if (b.x > e.x && b.x < e.x + e.w && b.y > e.y && b.y < e.y + e.h) {
                    e.hp--;
                    // Remove bullet (mark for delete)
                    b.y = -100; 
                    
                    if (e.hp <= 0) {
                        e.y = height + 100; // Kill enemy
                        score += 10;
                        // Chance for powerup
                        if (Math.random() < 0.1) spawnPowerup(e.x + e.w/2, e.y);
                    }
                }
            });

            // Collision: Enemy vs Players
            ['p1', 'p2'].forEach(pk => {
                const p = players[pk];
                if(p.active && Math.abs(p.x - (e.x + e.w/2)) < 30 && Math.abs(p.y - (e.y + e.h/2)) < 30) {
                    // Game Over logic
                   showGameOver();
                   if(isConnected) conn.send({ type: 'state', gameOver: true });
                }
            });
        });

        // Cleanup dead entities
        enemies = enemies.filter(e => e.y < height);
        bullets = bullets.filter(b => b.y !== -100);

        // Powerups
        powerups.forEach(p => {
            p.y += p.vy;
            ['p1', 'p2'].forEach(pk => {
                const ply = players[pk];
                if (ply.active && Math.abs(ply.x - p.x) < 30 && Math.abs(ply.y - p.y) < 30) {
                    ply.weaponLevel = 2; // Upgrade weapon
                    p.y = height + 100; // Remove powerup
                    setTimeout(() => ply.weaponLevel = 1, 5000); // Reset after 5s
                }
            });
        });
        powerups = powerups.filter(p => p.y < height);

        // Network Sync (Host -> Client)
        if (isConnected) {
            // Send normalized coordinates (0-1) to handle different screen sizes
            conn.send({
                type: 'state',
                score: score,
                p1: { x: players.p1.x / width, y: players.p1.y / height, active: players.p1.active },
                p2: { x: players.p2.x / width, y: players.p2.y / height, active: players.p2.active },
                bullets: bullets, // Sending full objects (optimize in prod)
                enemies: enemies,
                powerups: powerups,
                gameOver: false
            });
        }
    } 
    
    // --- CLIENT LOGIC ---
    else {
        // Client sends input to Host
        if (input.firing) {
            if (isConnected) {
                // Send normalized input position
                conn.send({ type: 'input', x: input.x / width, y: input.y / height });
            }
        }
    }
}

function draw() {
    // Clear screen
    ctx.fillStyle = '#050510';
    ctx.fillRect(0, 0, width, height);

    // Draw Stars (Simple background effect)
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    for(let i=0; i<20; i++) {
        const sx = (Date.now()/5 + i*100) % width;
        const sy = (Date.now()/2 + i*75) % height;
        ctx.fillRect(sx, sy, 2, 2);
    }

    // Draw Entities
    if(isHost || (!isHost && isConnected)) {
        
        // Powerups
        powerups.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.fillText("P", p.x-4, p.y+4);
        });

        // Bullets
        bullets.forEach(b => {
            ctx.fillStyle = b.color;
            ctx.fillRect(b.x - 2, b.y, 4, 10);
        });

        // Enemies
        ctx.fillStyle = '#00ff00';
        enemies.forEach(e => {
            // Draw Alien shape (simple rect with eyes)
            ctx.fillStyle = '#33cc33';
            ctx.fillRect(e.x, e.y, e.w, e.h);
            ctx.fillStyle = 'black';
            ctx.fillRect(e.x + 5, e.y + 10, 5, 5); // Eye L
            ctx.fillRect(e.x + e.w - 10, e.y + 10, 5, 5); // Eye R
        });

        // Players
        ['p1', 'p2'].forEach(pk => {
            const p = players[pk];
            if (p.active) {
                ctx.fillStyle = p.color;
                // Draw Ship (Triangle)
                ctx.beginPath();
                ctx.moveTo(p.x, p.y - 20);
                ctx.lineTo(p.x - 20, p.y + 20);
                ctx.lineTo(p.x + 20, p.y + 20);
                ctx.fill();
                
                // Engine flame
                ctx.fillStyle = 'orange';
                ctx.beginPath();
                ctx.moveTo(p.x - 10, p.y + 20);
                ctx.lineTo(p.x + 10, p.y + 20);
                ctx.lineTo(p.x, p.y + 30 + Math.random()*10);
                ctx.fill();
            }
        });
    }
    
    document.getElementById('score-board').innerText = "SCORE: " + score;
}

function loop() {
    update();
    draw();
    if(gameRunning) requestAnimationFrame(loop);
}

// Start Init
initNetwork();

</script>
</body>
</html>
