<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Alien Invasion</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            font-family: 'Courier New', Courier, monospace;
            color: white;
            touch-action: none;
        }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        
        .panel {
            background: rgba(0, 0, 0, 0.9);
            padding: 25px;
            border-radius: 10px;
            pointer-events: auto;
            border: 2px solid #00ffcc;
            max-width: 90%;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.2);
        }

        h1 { margin: 0 0 15px 0; color: #00ffcc; text-transform: uppercase; letter-spacing: 2px; }
        h2 { font-size: 16px; color: #ff0055; margin-bottom: 15px; }
        p { font-size: 14px; color: #ccc; margin-bottom: 15px; line-height: 1.4; }
        
        #qrcode { 
            margin: 15px auto; 
            background: white; 
            padding: 10px; 
            display: inline-block; 
            border-radius: 4px;
        }

        .hidden { display: none !important; }

        #score-board {
            position: absolute; top: 10px; left: 10px;
            font-size: 20px; font-weight: bold; color: white; z-index: 10;
            text-shadow: 0 0 5px #00ffcc;
        }
        
        #status {
            position: absolute; bottom: 10px; width: 100%;
            text-align: center; font-size: 12px; color: #666;
        }

        .btn {
            background: transparent;
            color: #00ffcc;
            border: 2px solid #00ffcc;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 5px;
            margin: 10px 0;
            cursor: pointer;
            width: 100%;
            font-family: inherit;
            font-weight: bold;
            transition: all 0.2s;
        }
        .btn:active { background: #00ffcc; color: black; }
        
        .btn-primary {
            background: #ff0055;
            border-color: #ff0055;
            color: white;
        }
        .btn-primary:active { background: #ff3377; }

    </style>
</head>
<body>

    <div id="score-board">SCORE: 0</div>
    <div id="status">Ready</div>

    <div id="ui-layer">
        
        <!-- MAIN MENU -->
        <div id="main-menu" class="panel">
            <h1>Alien Invasion</h1>
            <p>Defend Earth from the alien swarm.</p>
            <button class="btn btn-primary" onclick="startSinglePlayer()">SINGLE PLAYER</button>
            <button class="btn" onclick="setupMultiplayerUI()">MULTIPLAYER (CO-OP)</button>
        </div>

        <!-- MULTIPLAYER LOBBY -->
        <div id="lobby" class="panel hidden">
            <h1>Co-Op Lobby</h1>
            
            <div id="host-ui" class="hidden">
                <p>Scan this QR code with a second device to join.</p>
                <div id="qrcode"></div>
                <p style="color: #ffff00;">Waiting for Player 2...</p>
                <button class="btn" onclick="location.reload()">CANCEL</button>
            </div>

            <div id="client-ui" class="hidden">
                <p>Connecting to Host...</p>
            </div>
        </div>

        <!-- GAME OVER -->
        <div id="game-over-ui" class="panel hidden">
            <h1 style="color: #ff0055;">GAME OVER</h1>
            <p id="final-score">Score: 0</p>
            <button class="btn btn-primary" onclick="location.href = location.pathname">MAIN MENU</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * ENGINE SETUP
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width, height;

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
}
window.addEventListener('resize', resize);
resize();

// --- GAME STATE ---
let gameRunning = false;
let gameMode = 'none'; // 'single' or 'multi'
let score = 0;
let frames = 0;

// Entities
const players = {
    p1: { x: 0, y: 0, color: '#ff4d4d', active: true, hp: 3, weaponLevel: 1 }, // Local/Host
    p2: { x: 0, y: 0, color: '#4d4dff', active: false, hp: 3, weaponLevel: 1 } // Remote/Client
};
let bullets = [];
let enemies = [];
let powerups = [];

// Input
const input = { x: 0, y: 0, firing: false };

// --- NETWORKING STATE ---
let peer = null;
let conn = null;
const urlParams = new URLSearchParams(window.location.search);
const joinId = urlParams.get('id');
let isHost = true; 
let isConnected = false;

/**
 * INITIALIZATION FLOW
 */
window.onload = function() {
    // If ID exists in URL, we are a joiner, skip menu
    if (joinId) {
        startMultiplayerClient();
    }
};

function startSinglePlayer() {
    gameMode = 'single';
    isHost = true;
    document.getElementById('main-menu').classList.add('hidden');
    startGame();
}

function setupMultiplayerUI() {
    gameMode = 'multi';
    document.getElementById('main-menu').classList.add('hidden');
    document.getElementById('lobby').classList.remove('hidden');
    document.getElementById('host-ui').classList.remove('hidden');
    initNetworkHost();
}

function startMultiplayerClient() {
    gameMode = 'multi';
    isHost = false;
    document.getElementById('main-menu').classList.add('hidden');
    document.getElementById('lobby').classList.remove('hidden');
    document.getElementById('client-ui').classList.remove('hidden');
    initNetworkClient();
}

/**
 * PEERJS NETWORKING
 */
function initNetworkHost() {
    peer = new Peer(null, { debug: 1 });
    peer.on('open', (id) => {
        // Generate QR Code
        const gameUrl = `${window.location.protocol}//${window.location.host}${window.location.pathname}?id=${id}`;
        new QRCode(document.getElementById("qrcode"), {
            text: gameUrl, width: 180, height: 180
        });
    });

    peer.on('connection', (c) => {
        conn = c;
        setupConnectionEvents();
        players.p2.active = true; // Activate P2
        document.getElementById('lobby').classList.add('hidden');
        startGame();
    });
}

function initNetworkClient() {
    peer = new Peer(null, { debug: 1 });
    peer.on('open', () => {
        conn = peer.connect(joinId);
        setupConnectionEvents();
    });
}

function setupConnectionEvents() {
    conn.on('open', () => {
        isConnected = true;
        document.getElementById('status').innerText = "Connected!";
        
        if(!isHost) {
            document.getElementById('lobby').classList.add('hidden');
            startGame();
        }

        conn.on('data', (data) => {
            if (isHost) {
                // Host receives Input from Client
                if (data.type === 'input') {
                    players.p2.x = data.x * width;
                    players.p2.y = data.y * height;
                }
            } else {
                // Client receives State from Host
                if (data.type === 'state') {
                    players.p1.x = data.p1.x * width;
                    players.p1.y = data.p1.y * height;
                    players.p1.active = data.p1.active;
                    
                    players.p2.x = data.p2.x * width;
                    players.p2.y = data.p2.y * height;
                    players.p2.active = data.p2.active;

                    bullets = data.bullets; 
                    enemies = data.enemies;
                    powerups = data.powerups;
                    score = data.score;
                    if(data.gameOver) showGameOver();
                }
            }
        });
    });
    
    conn.on('close', () => {
        alert("Connection lost. Returning to menu.");
        location.href = location.pathname;
    });
}

/**
 * GAME ENGINE
 */
function startGame() {
    gameRunning = true;
    players.p1.x = width / 2;
    players.p1.y = height - 100;
    
    // In Single player, ensure P2 is dead
    if (gameMode === 'single') {
        players.p2.active = false;
        players.p2.x = -1000;
    }
    
    loop();
}

function showGameOver() {
    gameRunning = false;
    document.getElementById('ui-layer').style.pointerEvents = 'auto';
    document.getElementById('game-over-ui').classList.remove('hidden');
    document.getElementById('final-score').innerText = "Final Score: " + score;
}

// Input Handling
canvas.addEventListener('touchmove', handleInput, { passive: false });
canvas.addEventListener('touchstart', handleInput, { passive: false });
canvas.addEventListener('touchend', () => input.firing = false);
canvas.addEventListener('mousemove', (e) => {
    if(e.buttons === 1) {
        input.x = e.clientX;
        input.y = e.clientY;
        input.firing = true;
    } else input.firing = false;
});

function handleInput(e) {
    e.preventDefault();
    const t = e.touches[0];
    input.x = t.clientX;
    input.y = t.clientY - 50;
    input.firing = true;
}

// Logic Helpers
function spawnEnemy() {
    const size = 30 + Math.random() * 20;
    enemies.push({
        x: Math.random() * (width - size),
        y: -size, w: size, h: size,
        hp: Math.floor(1 + score / 500),
        speed: 2 + Math.random() * 2 + (score/2000)
    });
}

function spawnPowerup(x, y) {
    const types = ['spread', 'speed'];
    const type = types[Math.floor(Math.random() * types.length)];
    powerups.push({
        x: x, y: y, r: 10, type: type, vy: 2,
        color: type === 'spread' ? '#ffff00' : '#00ff00'
    });
}

function fireBullet(pkey) {
    const p = players[pkey];
    if (!p.active) return;
    
    if (frames % 10 === 0) {
        const velY = -10;
        if (p.weaponLevel === 1) {
            bullets.push({ x: p.x, y: p.y - 20, vx: 0, vy: velY, color: p.color });
        } else {
            bullets.push({ x: p.x, y: p.y - 20, vx: 0, vy: velY, color: p.color });
            bullets.push({ x: p.x, y: p.y - 20, vx: -3, vy: velY*0.9, color: p.color });
            bullets.push({ x: p.x, y: p.y - 20, vx: 3, vy: velY*0.9, color: p.color });
        }
    }
}

function update() {
    if (!gameRunning) return;
    frames++;

    // HOST (or Single Player) Logic
    if (isHost) {
        // Player 1 movement
        if (input.firing) {
            players.p1.x += (input.x - players.p1.x) * 0.2;
            players.p1.y += (input.y - players.p1.y) * 0.2;
            fireBullet('p1');
        }

        // Player 2 fire (Movement handled by network data)
        if (gameMode === 'multi' && players.p2.active && frames % 10 === 0) {
            fireBullet('p2');
        }

        // Spawners
        if (frames % 60 === 0) spawnEnemy();

        // Physics: Bullets
        bullets = bullets.filter(b => b.y > -50 && b.y < height && b.x > -50 && b.x < width+50);
        bullets.forEach(b => { b.x += b.vx; b.y += b.vy; });

        // Physics: Powerups
        powerups.forEach(p => {
            p.y += p.vy;
            ['p1', 'p2'].forEach(pk => {
                const ply = players[pk];
                if (ply.active && Math.hypot(ply.x - p.x, ply.y - p.y) < 30) {
                    ply.weaponLevel = 2;
                    p.y = height + 100;
                    setTimeout(() => ply.weaponLevel = 1, 5000);
                }
            });
        });
        powerups = powerups.filter(p => p.y < height);

        // Physics: Enemies
        enemies.forEach(e => {
            e.y += e.speed;
            
            // Hit by bullet
            bullets.forEach(b => {
                if (b.x > e.x && b.x < e.x + e.w && b.y > e.y && b.y < e.y + e.h) {
                    e.hp--; b.y = -100; // Remove bullet
                    if (e.hp <= 0) {
                        e.y = height + 100; score += 10;
                        if (Math.random() < 0.1) spawnPowerup(e.x + e.w/2, e.y);
                    }
                }
            });

            // Hit Player
            ['p1', 'p2'].forEach(pk => {
                const p = players[pk];
                if(p.active && Math.abs(p.x - (e.x + e.w/2)) < 30 && Math.abs(p.y - (e.y + e.h/2)) < 30) {
                   showGameOver();
                   if(isConnected) conn.send({ type: 'state', gameOver: true });
                }
            });
        });

        enemies = enemies.filter(e => e.y < height);
        bullets = bullets.filter(b => b.y !== -100);

        // Sync to Client
        if (gameMode === 'multi' && isConnected) {
            conn.send({
                type: 'state',
                score: score,
                p1: { x: players.p1.x / width, y: players.p1.y / height, active: players.p1.active },
                p2: { x: players.p2.x / width, y: players.p2.y / height, active: players.p2.active },
                bullets: bullets,
                enemies: enemies,
                powerups: powerups,
                gameOver: false
            });
        }
    } 
    // CLIENT Logic
    else {
        if (input.firing && isConnected) {
            conn.send({ type: 'input', x: input.x / width, y: input.y / height });
        }
    }
}

function draw() {
    ctx.fillStyle = '#050510';
    ctx.fillRect(0, 0, width, height);

    // Stars
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    for(let i=0; i<20; i++) {
        const sx = (Date.now()/5 + i*100) % width;
        const sy = (Date.now()/2 + i*75) % height;
        ctx.fillRect(sx, sy, 2, 2);
    }

    if(gameRunning || isHost === false) { // Draw if game running or if we are client waiting for data
        // Powerups
        powerups.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'black'; ctx.fillText("P", p.x-4, p.y+4);
        });

        // Bullets
        bullets.forEach(b => {
            ctx.fillStyle = b.color;
            ctx.fillRect(b.x - 2, b.y, 4, 10);
        });

        // Enemies
        ctx.fillStyle = '#33cc33';
        enemies.forEach(e => {
            ctx.fillRect(e.x, e.y, e.w, e.h);
            ctx.fillStyle = 'black';
            ctx.fillRect(e.x + 5, e.y + 10, 5, 5);
            ctx.fillRect(e.x + e.w - 10, e.y + 10, 5, 5);
            ctx.fillStyle = '#33cc33';
        });

        // Players
        ['p1', 'p2'].forEach(pk => {
            const p = players[pk];
            if (p.active) {
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.moveTo(p.x, p.y - 20);
                ctx.lineTo(p.x - 20, p.y + 20);
                ctx.lineTo(p.x + 20, p.y + 20);
                ctx.fill();
                
                // Flame
                ctx.fillStyle = 'orange';
                ctx.beginPath();
                ctx.moveTo(p.x - 10, p.y + 20);
                ctx.lineTo(p.x + 10, p.y + 20);
                ctx.lineTo(p.x, p.y + 30 + Math.random()*10);
                ctx.fill();
            }
        });
    }
    
    document.getElementById('score-board').innerText = "SCORE: " + score;
}

function loop() {
    update();
    draw();
    if(gameRunning) requestAnimationFrame(loop);
}

</script>
</body>
</html>
