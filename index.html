<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Striker: Portrait Ops</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Teko:wght@300;500;700&display=swap');

        :root {
            --p1: #00f3ff;
            --p2: #ff0055;
            --p3: #ffff00;
            --p4: #00ff66;
            --bg: #050508;
        }

        * {
            box-sizing: border-box;
            touch-action: none; /* Critical for mobile game controls */
            user-select: none;
            -webkit-user-select: none;
            outline: none;
        }

        body {
            margin: 0;
            background-color: var(--bg);
            overflow: hidden;
            font-family: 'Teko', sans-serif;
            color: white;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- HUD (Top of Screen) --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column;
        }

        .hud-top {
            padding: 10px 15px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            display: flex; justify-content: space-between; align-items: flex-start;
        }

        .score-box { font-size: 2rem; line-height: 1; color: #fff; text-shadow: 0 0 10px #fff; }
        .wave-box { font-size: 1.2rem; color: #888; }
        
        /* Health Bar */
        .hp-container {
            position: absolute; top: 50px; left: 15px; right: 15px;
            height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px;
        }
        .hp-bar {
            width: 100%; height: 100%; background: var(--p1);
            border-radius: 3px; transition: width 0.2s;
            box-shadow: 0 0 8px var(--p1);
        }

        /* --- CONTROLS (Floating Joysticks) --- */
        .joystick {
            position: absolute;
            width: 80px; height: 80px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            pointer-events: none; /* Touches pass through to the handler */
            display: none; /* Hidden until touched */
            transform: translate(-50%, -50%);
            z-index: 50;
        }
        
        .joystick-thumb {
            position: absolute; top: 50%; left: 50%;
            width: 40px; height: 40px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(255,255,255,0.5);
        }

        /* Weapon Switch Button */
        #weapon-btn {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 60px; height: 60px;
            background: rgba(0,0,0,0.6);
            border: 2px solid var(--p1);
            border-radius: 50%;
            color: var(--p1);
            font-size: 24px;
            display: flex; align-items: center; justify-content: center;
            pointer-events: auto;
            z-index: 100;
        }

        /* --- MENUS --- */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 8, 0.98);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 200;
            padding: 20px;
            text-align: center;
        }
        .hidden { display: none !important; }

        h1 {
            font-size: 4rem; margin: 0;
            background: linear-gradient(to bottom, var(--p1), var(--p2));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-transform: uppercase;
        }

        .btn {
            width: 100%; max-width: 300px;
            margin: 10px 0; padding: 15px;
            font-size: 1.5rem; font-family: inherit; font-weight: bold;
            background: transparent; color: var(--p1);
            border: 2px solid var(--p1); border-radius: 5px;
            cursor: pointer;
        }
        .btn:active { background: var(--p1); color: #000; }

        .lobby-panel {
            width: 100%; max-width: 350px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px; padding: 15px; margin: 20px 0;
        }
        .player-row {
            display: flex; justify-content: space-between;
            padding: 10px; border-bottom: 1px solid #333;
        }
        .ready { color: var(--p4); font-weight: bold; }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- UI LAYER -->
    <div id="ui-layer" class="hidden">
        <div class="hud-top">
            <div class="score-box" id="score">0</div>
            <div class="wave-box" id="wave">WAVE 1</div>
        </div>
        <div class="hp-container"><div class="hp-bar" id="hpBar"></div></div>
        
        <!-- Center Button to Switch Weapons -->
        <div id="weapon-btn">âš¡</div>

        <!-- Visual Joysticks (Created dynamically) -->
        <div id="joy-move" class="joystick"><div class="joystick-thumb"></div></div>
        <div id="joy-aim" class="joystick" style="border-color:rgba(255,0,85,0.5)"><div class="joystick-thumb" style="background:rgba(255,0,85,0.5)"></div></div>
    </div>

    <!-- MAIN MENU -->
    <div id="menu-screen" class="screen">
        <h1>NEON<br>STRIKER</h1>
        <p style="color:#666; margin-bottom:30px">PORTRAIT EDITION</p>
        <button class="btn" onclick="startSingle()">SINGLE PLAYER</button>
        <button class="btn" onclick="setupHost()">HOST MULTIPLAYER</button>
        <div id="join-msg" style="margin-top:20px; color:#aaa; font-size:12px">To join, scan Host QR</div>
    </div>

    <!-- LOBBY -->
    <div id="lobby-screen" class="screen hidden">
        <h2>LOBBY</h2>
        <div style="background:white; padding:10px; border-radius:8px;">
            <img id="qr-img" width="180" height="180">
        </div>
        <p style="font-size:12px; margin-top:5px; color:#888;">Scan to Join</p>
        
        <div class="lobby-panel" id="lobby-list">
            <!-- Populated by JS -->
        </div>
        <button class="btn" onclick="launchGame()">START GAME</button>
    </div>

    <!-- WAIT SCREEN -->
    <div id="wait-screen" class="screen hidden">
        <h1>CONNECTED</h1>
        <p>WAITING FOR HOST...</p>
        <div id="p-badge" style="width:50px; height:50px; background:white; border-radius:50%; box-shadow:0 0 20px white;"></div>
    </div>

<script>
/** 
 * GAME ENGINE FOR MOBILE PORTRAIT 
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let W, H;

// CONFIG
const COLORS = ['#00f3ff', '#ff0055', '#ffff00', '#00ff66'];

// STATE
let game = {
    running: false,
    mode: 'solo', // solo, host, client
    myId: 0,
    players: {},
    enemies: [],
    bullets: [],
    particles: [],
    score: 0,
    wave: 1
};

// INPUT (Twin Stick Logic)
const input = {
    move: { x: 0, y: 0, active: false, id: null, startX:0, startY:0 },
    aim: { x: 0, y: 0, active: false, id: null, startX:0, startY:0 },
    weapon: 0
};

// --- RESIZE ---
function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// --- TOUCH CONTROLS (FLOATING JOYSTICKS) ---
const joyMoveEl = document.getElementById('joy-move');
const joyAimEl = document.getElementById('joy-aim');
const weaponBtn = document.getElementById('weapon-btn');

document.addEventListener('touchstart', e => {
    if(!game.running) return;
    e.preventDefault();
    
    for(let i=0; i<e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        
        // Check weapon button click (Center Bottom)
        const btnRect = weaponBtn.getBoundingClientRect();
        if(t.clientX >= btnRect.left && t.clientX <= btnRect.right && 
           t.clientY >= btnRect.top && t.clientY <= btnRect.bottom) {
            input.weapon = (input.weapon + 1) % 3;
            weaponBtn.innerText = ['âš¡', 'ðŸ’¥', 'ðŸš€'][input.weapon];
            continue;
        }

        // Left Half = Move
        if(t.clientX < W/2 && !input.move.active) {
            input.move.active = true;
            input.move.id = t.identifier;
            input.move.startX = t.clientX;
            input.move.startY = t.clientY;
            
            // Visuals
            joyMoveEl.style.display = 'block';
            joyMoveEl.style.left = t.clientX + 'px';
            joyMoveEl.style.top = t.clientY + 'px';
            joyMoveEl.querySelector('.joystick-thumb').style.transform = `translate(-50%, -50%)`;
        }
        
        // Right Half = Aim
        else if(t.clientX >= W/2 && !input.aim.active) {
            input.aim.active = true;
            input.aim.id = t.identifier;
            input.aim.startX = t.clientX;
            input.aim.startY = t.clientY;
            
            // Visuals
            joyAimEl.style.display = 'block';
            joyAimEl.style.left = t.clientX + 'px';
            joyAimEl.style.top = t.clientY + 'px';
            joyAimEl.querySelector('.joystick-thumb').style.transform = `translate(-50%, -50%)`;
        }
    }
}, {passive:false});

document.addEventListener('touchmove', e => {
    if(!game.running) return;
    e.preventDefault();

    for(let i=0; i<e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        
        // Move Logic
        if(t.identifier === input.move.id) {
            let dx = t.clientX - input.move.startX;
            let dy = t.clientY - input.move.startY;
            const dist = Math.min(Math.hypot(dx, dy), 40); // 40px radius
            const angle = Math.atan2(dy, dx);
            
            input.move.x = (Math.cos(angle) * dist) / 40;
            input.move.y = (Math.sin(angle) * dist) / 40;
            
            // Update visual thumb
            const tx = Math.cos(angle) * dist;
            const ty = Math.sin(angle) * dist;
            joyMoveEl.querySelector('.joystick-thumb').style.transform = `translate(calc(-50% + ${tx}px), calc(-50% + ${ty}px))`;
        }
        
        // Aim Logic
        if(t.identifier === input.aim.id) {
            let dx = t.clientX - input.aim.startX;
            let dy = t.clientY - input.aim.startY;
            const dist = Math.min(Math.hypot(dx, dy), 40);
            const angle = Math.atan2(dy, dx);
            
            input.aim.x = Math.cos(angle);
            input.aim.y = Math.sin(angle);
            
            const tx = Math.cos(angle) * dist;
            const ty = Math.sin(angle) * dist;
            joyAimEl.querySelector('.joystick-thumb').style.transform = `translate(calc(-50% + ${tx}px), calc(-50% + ${ty}px))`;
        }
    }
}, {passive:false});

document.addEventListener('touchend', e => {
    e.preventDefault();
    for(let i=0; i<e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if(t.identifier === input.move.id) {
            input.move.active = false;
            input.move.x = 0; input.move.y = 0;
            joyMoveEl.style.display = 'none';
        }
        if(t.identifier === input.aim.id) {
            input.aim.active = false;
            // Don't reset aim vector so we keep shooting last direction? 
            // Better to stop shooting.
            joyAimEl.style.display = 'none';
        }
    }
}, {passive:false});

// --- AUDIO ---
const actx = new (window.AudioContext || window.webkitAudioContext)();
function sfx(type) {
    if(actx.state==='suspended') actx.resume();
    const o = actx.createOscillator();
    const g = actx.createGain();
    const t = actx.currentTime;
    o.connect(g); g.connect(actx.destination);
    
    if(type==='shoot') {
        o.frequency.setValueAtTime(300, t);
        o.frequency.exponentialRampToValueAtTime(50, t+0.1);
        g.gain.setValueAtTime(0.1, t);
        g.gain.linearRampToValueAtTime(0, t+0.1);
        o.start(); o.stop(t+0.1);
    } else { // Boom
        o.type='sawtooth';
        o.frequency.setValueAtTime(100, t);
        o.frequency.exponentialRampToValueAtTime(10, t+0.3);
        g.gain.setValueAtTime(0.2, t);
        g.gain.linearRampToValueAtTime(0, t+0.3);
        o.start(); o.stop(t+0.3);
    }
}

// --- LOGIC ---

function init() {
    game.players[game.myId] = { x: W/2, y: H/2, hp: 100, active: true, color: COLORS[game.myId], id: game.myId };
    
    document.getElementById('menu-screen').classList.add('hidden');
    document.getElementById('lobby-screen').classList.add('hidden');
    document.getElementById('wait-screen').classList.add('hidden');
    document.getElementById('ui-layer').classList.remove('hidden');
    
    // Set UI Color
    document.querySelector('.hp-bar').style.backgroundColor = COLORS[game.myId];
    document.querySelector('.hp-bar').style.boxShadow = `0 0 10px ${COLORS[game.myId]}`;
    
    game.running = true;
    requestAnimationFrame(loop);
}

const WEAPONS = [
    { rate: 10, count: 1, spread: 0, speed: 12, dmg: 20 }, // Pulse
    { rate: 25, count: 3, spread: 0.3, speed: 10, dmg: 15 }, // Spread
    { rate: 50, count: 1, spread: 0, speed: 20, dmg: 80 }  // Rocket
];

function update() {
    if(!game.running) return;

    // 1. Player Logic (Local)
    const p = game.players[game.myId];
    if(p && p.hp > 0) {
        // Move
        p.x += input.move.x * 5;
        p.y += input.move.y * 5;
        p.x = Math.max(15, Math.min(W-15, p.x));
        p.y = Math.max(15, Math.min(H-15, p.y));
        
        // Aim/Shoot
        if(input.aim.active) {
            const w = WEAPONS[input.weapon];
            const now = Date.now();
            if(!p.lastShot || now - p.lastShot > (1000/60)*w.rate) {
                p.lastShot = now;
                sfx('shoot');
                
                // Angle
                const baseAng = Math.atan2(input.aim.y, input.aim.x);
                
                // If Host/Solo, create bullet directly
                // If Client, send input to Host
                if(game.mode !== 'client') {
                    for(let i=0; i<w.count; i++) {
                        const a = baseAng - (w.spread*(w.count-1))/2 + (w.spread*i);
                        game.bullets.push({
                            x: p.x, y: p.y, 
                            vx: Math.cos(a)*w.speed, vy: Math.sin(a)*w.speed,
                            c: p.color, dmg: w.dmg, owner: game.myId
                        });
                    }
                }
            }
        }
    }

    // 2. Host Logic
    if(game.mode !== 'client') {
        // Spawn Enemies (Portrait: Spawn mostly Top, some sides)
        if(Math.random() < 0.03 + (game.wave*0.005)) {
            let ex, ey;
            const r = Math.random();
            if(r < 0.6) { ex = Math.random()*W; ey = -30; } // 60% Top
            else if(r < 0.8) { ex = -30; ey = Math.random()*H*0.6; } // Left
            else { ex = W+30; ey = Math.random()*H*0.6; } // Right
            
            game.enemies.push({
                x: ex, y: ey,
                hp: 30 + (game.wave*10), maxHp: 30 + (game.wave*10),
                speed: 1 + (game.wave*0.1),
                target: Math.floor(Math.random() * Object.keys(game.players).length) // Simple target logic
            });
        }

        // Enemies Move
        game.enemies.forEach(e => {
            // Find nearest player
            let target = null;
            let dist = 9999;
            for(let id in game.players) {
                let pl = game.players[id];
                if(pl.hp > 0) {
                    let d = Math.hypot(pl.x - e.x, pl.y - e.y);
                    if(d < dist) { dist = d; target = pl; }
                }
            }
            
            if(target) {
                const ang = Math.atan2(target.y - e.y, target.x - e.x);
                e.x += Math.cos(ang) * e.speed;
                e.y += Math.sin(ang) * e.speed;
            } else {
                e.y += e.speed; // Just move down if no target
            }
        });

        // Collisions
        for(let i=game.bullets.length-1; i>=0; i--) {
            let b = game.bullets[i];
            b.x += b.vx; b.y += b.vy;
            if(b.x<0||b.x>W||b.y<0||b.y>H) { game.bullets.splice(i,1); continue; }
            
            // Vs Enemy
            for(let j=game.enemies.length-1; j>=0; j--) {
                let e = game.enemies[j];
                if(Math.hypot(b.x-e.x, b.y-e.y) < 25) {
                    e.hp -= b.dmg;
                    game.bullets.splice(i,1);
                    // Particles
                    game.particles.push({x:b.x, y:b.y, c:b.c, life:1});
                    if(e.hp <= 0) {
                        game.enemies.splice(j,1);
                        game.score += 50;
                        sfx('boom');
                    }
                    break;
                }
            }
        }
        
        // Enemy vs Player
        for(let j=game.enemies.length-1; j>=0; j--) {
            let e = game.enemies[j];
            for(let id in game.players) {
                let pl = game.players[id];
                if(pl.hp > 0 && Math.hypot(e.x-pl.x, e.y-pl.y) < 25) {
                    pl.hp -= 20;
                    game.enemies.splice(j,1);
                    sfx('boom');
                }
            }
        }
        
        if(game.score > game.wave * 1000) game.wave++;
        
        // Broadcast
        if(game.mode === 'host') {
            const packet = { 
                t: 's', 
                pl: game.players, 
                en: game.enemies, 
                bu: game.bullets, 
                sc: game.score, 
                wv: game.wave 
            };
            for(let c of conns) c.send(packet);
        }
    } else {
        // Client: Send Input
        if(conn && conn.open) {
            conn.send({ 
                t: 'i', 
                x: game.players[game.myId].x, 
                y: game.players[game.myId].y,
                fire: input.aim.active,
                ax: input.aim.x, ay: input.aim.y,
                w: input.weapon
            });
        }
    }
    
    // UI
    document.getElementById('score').innerText = game.score;
    document.getElementById('wave').innerText = "WAVE " + game.wave;
    if(game.players[game.myId]) {
        document.getElementById('hpBar').style.width = Math.max(0, game.players[game.myId].hp) + '%';
    }
}

function draw() {
    ctx.fillStyle = '#050508';
    ctx.fillRect(0,0,W,H);
    
    // Grid (Vertical scrolling effect)
    ctx.strokeStyle = '#111122';
    ctx.lineWidth = 1;
    const off = (Date.now() * 0.1) % 50;
    ctx.beginPath();
    for(let x=0; x<W; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x,H); }
    for(let y=off; y<H; y+=50) { ctx.moveTo(0,y); ctx.lineTo(W,y); }
    ctx.stroke();
    
    ctx.globalCompositeOperation = 'lighter';
    
    // Particles
    for(let i=game.particles.length-1; i>=0; i--) {
        let p = game.particles[i];
        ctx.fillStyle = p.c;
        ctx.beginPath(); ctx.arc(p.x, p.y, 4*p.life, 0, Math.PI*2); ctx.fill();
        p.life -= 0.1;
        if(p.life<=0) game.particles.splice(i,1);
    }

    // Bullets
    game.bullets.forEach(b => {
        ctx.fillStyle = b.c;
        ctx.shadowColor = b.c; ctx.shadowBlur = 10;
        ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill();
    });
    
    // Enemies
    game.enemies.forEach(e => {
        ctx.fillStyle = '#ff0055';
        ctx.shadowColor = '#ff0055'; ctx.shadowBlur = 15;
        ctx.beginPath(); 
        ctx.moveTo(e.x, e.y+15); ctx.lineTo(e.x-12, e.y-12); ctx.lineTo(e.x+12, e.y-12); 
        ctx.fill();
    });
    
    // Players
    for(let id in game.players) {
        let p = game.players[id];
        if(p.active && p.hp > 0) {
            ctx.fillStyle = '#000';
            ctx.strokeStyle = p.color;
            ctx.lineWidth = 3;
            ctx.shadowColor = p.color; ctx.shadowBlur = 20;
            
            ctx.beginPath();
            ctx.arc(p.x, p.y, 18, 0, Math.PI*2);
            ctx.fill(); ctx.stroke();
            
            // Name
            ctx.fillStyle = '#fff'; ctx.font='10px Arial'; ctx.textAlign='center';
            ctx.shadowBlur=0;
            ctx.fillText("P"+(parseInt(id)+1), p.x, p.y+4);
        }
    }
    
    ctx.globalCompositeOperation = 'source-over';
    requestAnimationFrame(loop);
}

function loop() {
    update();
    draw();
    if(game.running) requestAnimationFrame(loop);
}

// --- NETWORKING ---
let peer, conn, conns = [];

function startSingle() {
    game.myId = 0;
    init();
}

function setupHost() {
    game.mode = 'host';
    game.myId = 0;
    document.getElementById('menu-screen').classList.add('hidden');
    document.getElementById('lobby-screen').classList.remove('hidden');
    updateLobbyUI();

    peer = new Peer();
    peer.on('open', id => {
        const url = window.location.href.split('?')[0] + '?join=' + id;
        document.getElementById('qr-img').src = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${encodeURIComponent(url)}`;
    });
    
    peer.on('connection', c => {
        if(conns.length >= 3) return; // Max 4
        conns.push(c);
        const newId = conns.length;
        game.players[newId] = { active:true, color:COLORS[newId] };
        updateLobbyUI();
        
        c.on('open', () => c.send({ t:'welcome', id:newId }));
        c.on('data', d => {
            if(d.t === 'i') {
                // Input Sync
                let p = game.players[newId];
                if(p) { 
                    p.x = d.x; p.y = d.y; 
                    if(d.fire) {
                         const w = WEAPONS[d.w];
                         const now = Date.now();
                         if(!p.lastShot || now - p.lastShot > (1000/60)*w.rate) {
                             p.lastShot = now;
                             sfx('shoot');
                             const base = Math.atan2(d.ay, d.ax);
                             for(let i=0; i<w.count; i++) {
                                 const a = base - (w.spread*(w.count-1))/2 + (w.spread*i);
                                 game.bullets.push({x:p.x, y:p.y, vx:Math.cos(a)*w.speed, vy:Math.sin(a)*w.speed, c:p.color, dmg:w.dmg, owner:newId});
                             }
                         }
                    }
                }
            }
        });
    });
}

function updateLobbyUI() {
    const list = document.getElementById('lobby-list');
    list.innerHTML = '';
    
    // Host
    list.innerHTML += `<div class="player-row"><span style="color:${COLORS[0]}">P1 (HOST)</span><span class="ready">READY</span></div>`;
    
    // Clients
    conns.forEach((c, i) => {
        list.innerHTML += `<div class="player-row"><span style="color:${COLORS[i+1]}">P${i+2}</span><span class="ready">READY</span></div>`;
    });
}

function launchGame() {
    conns.forEach(c => c.send({ t:'start' }));
    init();
}

// Client
const urlParams = new URLSearchParams(window.location.search);
const joinId = urlParams.get('join');

if(joinId) {
    game.mode = 'client';
    document.getElementById('menu-screen').classList.add('hidden');
    document.getElementById('wait-screen').classList.remove('hidden');
    
    peer = new Peer();
    peer.on('open', () => {
        conn = peer.connect(joinId);
        conn.on('data', d => {
            if(d.t === 'welcome') {
                game.myId = d.id;
                const b = document.getElementById('p-badge');
                b.style.backgroundColor = COLORS[game.myId];
                b.style.boxShadow = `0 0 20px ${COLORS[game.myId]}`;
            }
            if(d.t === 'start') init();
            if(d.t === 's') {
                // Sync State
                game.enemies = d.en;
                game.bullets = d.bu;
                game.score = d.sc;
                game.wave = d.wv;
                // Sync other players
                for(let id in d.pl) {
                    if(parseInt(id) !== game.myId) game.players[id] = d.pl[id];
                    else game.players[game.myId].hp = d.pl[id].hp; // Only sync HP for self
                }
            }
        });
    });
}

</script>
</body>
</html>
